---
layout: post
title: 'MySQL 事务隔离级别'
tags: [code]
---

### 事务隔离级别

当数据库上有多个事务同时执行时，会出现脏读、不可重复读、幻读的问题，为了解决这些问题，就有了事务的隔离级别。

四种隔离级别：

- Read Uncommitted 
- Read Committed 
- Repeatable Read
- Serializable

在 MYSQL 中读未提交是直接返回记录上的最新值。不做任何其他限制操作，所以事务之间可以读到未提交的修改。读提交是在每个 SQL 执行开始，创建一个 consistent read view 。可重复读是在事务开始创建一个 consistent read view ，在这个事务中都用这个 consistent read view 来保证一个事务中数据可重复读。串行化是加锁实现的，后访问的事务要等前一个事务执行完成，才能继续执行。

---

### MVCC

consistent read view 是 MVCC（Multi-Version Concurrency Control）重要的组成部分。有点像 Git 里面，每提交一个修改，就创建一个视图，指针指到最新的视图上，同时保留历史视图，方便回退操作。同一条记录会有多个版本，这就是数据库的多版本并发控制。

回滚记录会在没有事务需要它们的时候被删除，所以尽量不要出现长事务，因为一个长事务会有大量回滚日志，除了占用空间，长事务还占用锁资源，可能拖垮整个数据库。

那么 MVCC 是怎么实现事务之间的隔离级别的？其实是通过几个字段的比对，判断数据的可见性，起到数据隔离的目的。

先介绍下这几个字段：

在 InnoDB 中，表中的每一行都有三个系统隐藏列：

- DATA_ROW_ID：记录主键，如果没有主键，则采用 MySQL 自己生成的 ROW_ID
- DATA_TRX_ID：记录事务的 ID
- DATA_ROLL_PTR：指针，指向回滚段，组成 UNDO 日志链表

在  read view 中有三个变量：

- low_limit_id：表示创建 read-view 那一刻活跃的事务中，最大的事务 ID
- up_limit_id：表示创建 read-view 那一刻活跃的事务中，最小的事务 ID
- trx_ids：表示创建 read-view 那一刻活跃的事务的 ID 的集合

#### 判断记录可见

有几条规则来判断表中的一条数据是否可见：

1. 当记录的 DATA_TRX_ID 小于 up_limit_id，说明这条记录是在创建 consistent read view 之前就提交了，所以记录可见。
2. 如果记录 DATA_TRX_ID 和事务创建者的 TRX_ID 一致，记录可见。
3. 当记录的 DATA_TRX_ID 大于 up_limit_id 说明该记录是在创建 consistent read view 之后其他新事务提交的，记录不可见。
4. 在 RR 隔离级别下，两个事务 A 和 B 它们中对数据的修改互相是不可见的，因此，如果 DATA_TRX_ID 在 trx_ids 里，该记录不可见。

通过这种方式就用 MVCC 实现了事务的隔离，因为没有锁的存在，它的并发性能很好。但它只能 cover 读的场景，如果有写的操作，就涉及到另一个概念——当前读。

为什么写操作要「当前读」呢？举个例子，事务 A 和事务 B，B 中对 k 值做了修改，并且提交了。事务 A 再次要修改 k 的时候，就要「当前读」，即读到 B 修改后的值。否则，B 的修改就丢失了。

在更新数据的时候，要先当前读，这时要保证其他事务不会修改数据，所以要加锁了。如果能命中索引就加行锁，不能命中就加表锁。但行锁不能阻止 insert ，当锁住一些行进行 update 操作的时候，其他事务 insert 进来一条数据，再查的时候，发现多了一条数据，这就是幻读。在 InnoDB 中，为了解决这个问题，引入了 Next-key   锁，它是行锁和 GAP 锁的结合。那什么是 GAP 锁？

比如你要更新数据的范围是 （10，20），GAP 锁会帮你把 1-10，20-N 这些可能插入数据的 GAP 都锁住，其他事务就不能插入数据了，所以就不会出现幻读了。

---

### 一些问题

#### UNDO 日志

UNDO 日志是 MVCC 的重要组成部分，它记录了修改的记录。通过指针，形成一个链表。如果判断不可见，就通过指针找到上一条数据，直到找到可见的数据为止。这个日志是软删除，它有一个 deleted 标记位，被删除的标记为 1，有一个 purge 线程会不定期的清理这些日志。但是如果，执行一个查询，扫描区间有大量的被标记为 deleted 但是还没有删除的日志，这个查询就会很慢。

所以要尽量避免长事务，可以监控长事务的个数，进行告警，如果出现问题，及时 kill 掉会话。

#### 锁竞争优化

因为有锁的存在，为了避免锁冲突，有时可以做这样的优化。

比如，顾客 A 要在影院 B 买票，要执行以下操作：

1. 从顾客 A 的账户扣钱
2. 给影院 B 的账户加钱
3. 记录一条交易日志

那么要把可能产生冲突的操作尽量放在后面，顺序为 312，2 的操作是会产生冲突的，因为可能有其他人也在同时买电影票。放在最后，就能尽量减少锁的时间。

####  死锁

有以下策略来避免死锁：

1. 设置超时参数 innodb_lock_wait_timeout 
2. 主动检测死锁，将参数 innode_deadlock_detect 设置为 on ，主动回滚死锁链条中的一个事务，让其他事务得以继续执行。
3. 在同一个事务中，尽可能锁住所有需要的资源
4. 如果业务允许，降低隔离级别
5. 为表添加合理的索引，因为不走索引就会锁表

innode_deadlock_detect 的开启很耗费 CPU 资源，降低事务处理能力。
还有一种思路是做并发控制，对相同行的更新，在进入引擎之前排队，这可能要通过修改中间件或 MYSQL 的源码实现。

还可以在设计上做优化，上面电影院的例子，可以考虑把影院账户放在多条记录上，如果你了解 LongAdder 可以这样类比，它们的设计思想差不多，每次要给账户增加金额，随机选择一条记录来加，这就降低了冲突的概率。

---

### 总结

MySQL InnoDB 中有四种隔离级别，最常用的也是最难理解的是 RR 级别。实现事务的隔离牵扯出 MVCC，它是由 consistent read view 实现，通过比较 consistent read view 和数据库中系统列来确定一条数据是否可见。这种方式通过构建版本不加锁实现高并发的读，但无法 cover 写的场景。写就要加锁了，InnoDB 中，有很多种锁，命中索引走行锁，否则走表锁，所以要尽量命中索引，InnoDB 为了解决 RR 级别下幻读问题，还提出了 Next-key 锁。



