---
layout: post
title: 'Fragment基本用法'
tags: [code]
---

本文是介绍Fragment的用法说明，下面是本文将要涉及到的点：

- 关于Fragment
- Fragment生命周期
- 静态添加 Fragment
- 动态添加 Fragment
- Fragment 回退栈



### #关于Fragment
相比于Activity,fragment比较轻量级。可以更好的在平板上进行显示。
Fragment是在3.0版本引入的，如果是3.0，即API 11 以下的版本，需要导入android-support-v4的jar包才能使用。


### #Fragment 生命周期

这是我看到的最全的fragment的生命周期图。如果只是简单的使用fragment一般只需要知道其中的一些常用的即可：

![Lifecycle](http://i3.tietuku.com/5cecb0f6504c5705.jpg)

- onAttach方法：Fragment和Activity建立关联时调用。
- onCreateView方法：为Fragment加载布局时调用。
- onActivityCreated方法：当Activity中的onCreate方法执行完调用。
- onDestroyView方法：Fragment布局被移除时调用。
- onDetach方法：Fragment和Activity解除关联时调用。

### #静态添加 Fragment
静态添加Fragment是最简单的一种方式。   
只需要以下几步：   
1.新建Fragment类继承自Fragment以及自定义Layout布局   
2.在自定义Fragment类中，调用onCreateView方法，加载布局。   
3.在主Activity的Layout布局文件中添加fragment标签，name为所建Fragment的包名加类名。要添加id，否则会报错。   
经过以上几步，就可以静态的加载Fragment了，非常简单，就不举例了。

### #动态添加 Fragment
动态加载Fragment相对静态复杂了一点，它有更高的灵活性。在静态添加中，我们在activity_main.xml中添加了fragment，在动态添加中就不需要了，只需给最外层布局添加一个id，就可以根据id，把fragment加载进这个布局。


    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"   
    android:id="@+id/main_layout"   
    android:layout_width="match_parent"   
    android:layout_height="match_parent"   
    android:orientation="horizontal">
    </LinearLayout>

在MainActivity中   
   
    public class MainActivity extends Activity {

     protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        FragmentA fragment1 = new FragmentA();
        getFragmentManager().beginTransaction().replace(R.id.main_layout,fragment1).commit();
    }
    }
这段代码做了这些事：   
1.通过getFragmentManager得到FragmentManager 。  
2.通过beginTransaction开启一个事务。   
3.向容器内添加Fragment,一般用replace。    
4.一定不要忘了，commit提交事务。    

### #Fragment 回退栈

    public class FragmentA extends Fragment {

    private Button btn;
    private EditText et_a;
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        Log.i("tyq","onCreateView");
        return inflater.inflate(R.layout.fragment_a,container,false);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        btn = (Button)getActivity().findViewById(R.id.btn_a);
        et_a = (EditText)getActivity().findViewById(R.id.et_a);
        btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
			FragmentB fragment2 = new FragmentB();
               FragmentManager fm =  getFragmentManager();
                FragmentTransaction ft = fm.beginTransaction();
				//添加回退栈
                ft.addToBackStack(null).add(R.id.main_layout, fragment2);
                ft.hide(FragmentA.this);
                ft.commit();

            }
        });
    }
    @Override
    public void onDestroyView() {
        super.onDestroyView();
        Log.i("tyq","onDestroyView");
    }
    }   
上面这段是我测试的add方法的代码。注释的地方为添加回退栈。    
add和replace的区别：   

- replace相当于remove()+add()，replace后会销毁视图。测试点击Button进入FragmentB，会调用onDestroyView()，回到FragmentA,调用onCreate()。如果没有添加回退栈，那么FragmentA实例将被销毁。



  

   

