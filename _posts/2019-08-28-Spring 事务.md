---
layout: post
title: 'Spring 事务'
tags: [Spring]
---

### 认识事务
事务是用来保证一组操作最终的一致性，这组操作要么同时完成，要么同时失败。比如 A 给 B 转账，涉及两个操作，A 的账户金额减少，B 的账户金额增加，这两个操作要在一个事务内完成。
我们常说事务包含四个属性，ACID

- Atomicity ：全部操作是一个不可分割的整体，要么全部成功，要么全部失败。

- Consistent ：比如，A 的账户有 10 万元，B 的账户 0 元，两个账户加起来是 10 万元，A 给 B 转账 5 万元后，A 和 B 两个账户加起来总和依然是 10 万元，如果操作结束后数据不是这样，就发生了不一致，事务就是用来避免这种不一致的。

- Isolation ：隔离性规定了各个事务之间的影响，主要面向并发资源访问。设置不同的隔离级别决定了各事务对数据访问的不同行为。

- Durability ：一旦事务提交成功，数据变更不可逆转。

---

### 事务的隔离级别

- Read Uncommitted ：读未提交，最低的隔离级别，A 和 B 两个事务，A 事务只要修改了数据，B 事务中就能看到，会发生脏读问题。

- Read Committed：读已提交，只有 A 事务提交了 B 事务才能看到修改。避免了脏读问题，但是在一个事务中，无法做到可重复读，比如，A 事务查询一个数据，B 事务修改了这条数据并且提交，A 事务此时再查询这条数据，就跟之前不一样了。

- Repeatable Read：可重复读，MYSQL 中默认是这个级别，可以保证在一个事务中，前后读取的数据是一致的。避免了不可重复读问题。但依然无法避免幻读。比如，A 事务查询了一个范围中的数据，并对它们做了修改。B 事务此时在该范围内插入了一条数据，A 再次查询这个范围的数据，就发现有一条数据没有被修改。这就是幻读。

- Serializable：串行，这是最高的隔离界别，所有事务都要等待正在执行的事务执行完才能进行操作。


@Transactional 注解中可以设置高于数据库的隔离级别。
隔离界别与并发性能成反比，隔离级别越高，并发性能越差，但是隔离级别的增高，能更好的保证数据的一致性。

---

###  事务的传播行为

表示整个事务处理过程所跨越的业务对象，将以什么样的行为参与事务。比如，ServiceA.method() 中调用了 ServiceB.method() 它们应该是在一个事务中，还是新启一个事务，还是其他形式，这个是通过传播行为的定义确定的。

有以下几种传播行为：

- Required：这个是默认的，如果当前存在一个事务，则加入这个事务，如果不存在，就新建一个事务。

- supports：如果当前存在一个事务，则加入这个事务，如果没有事务，就直接执行，不需要事务。

- not_supports：不支持当前的事务，如果存在事务，将当前事务挂起。

- mandatory：强制要求当前存在一个事务，如果不存在，就抛出异常。

- require_new：不管是否存在事务，都新开一个事务，如果存在一个事务，挂起这个事务。如果某个业务对象做的事不希望影响外面的事务，可以用这个，比如，当前方法记录一些日志，即使记录失败也不希望影响外面方法的执行。但有一个前提，inner 方法抛出的异常时 Checked Exception 而不是 RuntimeException。如果是 RuntimeException 都会回滚。

- never：永远不需要事务，如果存在，抛出异常。

- nested：如果存在事务，则在这个事务的嵌套事务中执行，否则新建事务。

---

### pitfall

使用 Spring 事务注解要注意

1. 只能在 public 方法上面使用。
2. 在同一个类中，A 方法调用 B 方法，A 方法没有事务注解，B 方法即使添加事务注解也是无效的。因为 Spring AOP 机制，动态代理生成的类中 A 方法直接调用了 B 方法，没有进行增强。
3. 加了 @Transactional 注解后，就不需要显示的调用 save 方法了，因为事务在结束后，会对数据的修改进行提交。如果手动添加 save 方法，可能由于疏忽出现以下问题

```java
@Transactional
public void changeName(long id, String name) {
  User user = userRepository.getById(id);
  user.setName(name);
   
   // 这个 if 判断是失效的
  if (StringUtils.isNotEmpty(name)) {
    userRepository.save(user);
  }
}
```
---

### 扩展
我们一般把事务管理放在 Service 层，将数据访问放在 DAO 层，在 Service 层会有多个对 DAO 层的数据访问。那怎么保证它们使用的是同一个 Connection 呢？Spring 的做法是，把 Connection 放在 ThreadLocal 中，这样就不需要 connection-pass 传递这个 Connection 了。