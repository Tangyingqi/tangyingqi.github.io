<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/06/HeadFirst设计模式笔记-装饰者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/06/HeadFirst设计模式笔记-装饰者模式/" itemprop="url">HeadFirst设计模式笔记-装饰者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-06T14:13:50+08:00">
                2015-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h3><p>装饰者模式是相对比较容易理解的一种模式，因为我们在Java，IO流的部分经常会用到，BufferedInputStream（FileInputStream）就是一个装饰者模式。     </p>
<p>主要由组件（components）和装饰器（Decorator）组成，组件被装饰器装饰。</p>
<ul>
<li>装饰者和被装饰对象有相同的超类型。</li>
<li>你可以用一个或多个装饰者包装一个对象。</li>
<li>既然装饰者和被装饰者拥有相同超类型，所以在任何需要原始对象(被包装的)的场合，可以用装饰过的对象代替它。</li>
<li>装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。</li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。</li>
</ul>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>一个咖啡店，它有一些原味的咖啡，但是顾客的需求是复杂的，顾客会要求加一些奶泡、摩卡之类的，顾客的需求千变万化，加不同的的东西价格就会不一样，所以要灵活的设计。下面这个例子，我们会有两种类型的咖啡，两种调料。调料是装饰者，咖啡是被装饰者。</p>
<p>首先，我们定义一个饮料的抽象类，实现一些共有方法。</p>
<pre><code>public abstract class Beverage {
String description = &quot;unKnow Beverage&quot;;
public String getDescription(){
    return description;
}
public abstract double cost();
}
</code></pre><p>然后我们需要一个调料装饰者的抽象类，这个类继承上面的饮料抽象类。目的是，装饰者和被装饰对象有相同的超类型。</p>
<pre><code>public abstract class CondimentDecorator extends Beverage{
public abstract String getDescription();
}
</code></pre><p>下面是第一种类型的咖啡</p>
<pre><code>public class Espresso extends Beverage{

public Espresso() {
    description = &quot;Espresso&quot;;
}
@Override
public double cost() {
    return 1.99;
}
}
</code></pre><p>下面是第二种类型的咖啡</p>
<pre><code>public class HouseBlend extends Beverage{

public HouseBlend() {
    description = &quot;HouseBlend&quot;;
}
@Override
public double cost() {
    return 1.89;
}
}
</code></pre><p>我们定义两中调料，也就是装饰者。下面是摩卡调料</p>
<pre><code>public class Mocha extends CondimentDecorator{

Beverage beverage;
public Mocha(Beverage beverage) {
    this.beverage = beverage;
}
@Override
public String getDescription() {
    return beverage.getDescription()+&quot;,Mocha&quot;;
}

@Override
public double cost() {
    return 0.2+beverage.cost();
}
}
</code></pre><p>下面是第二种，奶泡调料</p>
<pre><code>public class Whip extends CondimentDecorator{

Beverage beverage;
public Whip(Beverage beverage) {
    this.beverage = beverage;
}
@Override
public String getDescription() {
    return beverage.getDescription()+&quot;,Whip&quot;;
}

@Override
public double cost() {
    return 1.2+beverage.cost();
}
}
</code></pre><p>装饰者和被装饰者都到齐了，下面我们可以开始使用装饰者模式了。</p>
<pre><code>public class Coffee {
public static void main(String[] args) {
    Beverage beverage = new Espresso();
    System.out.println(beverage.getDescription()+&quot; $&quot;+beverage.cost());

    Beverage beverage2 = new HouseBlend();
    beverage2 = new Mocha(beverage2);
    beverage2 = new Whip(beverage2);
    System.out.println(beverage2.getDescription()+&quot; $&quot;+beverage2.cost());
}
}
</code></pre><p>结果是：<br>Espresso $1.99<br>HouseBlend,Mocha,Whip $3.29</p>
<p>beverage2运用了装饰者模式，首先创建一种咖啡，然后放入Mocha，然后再一起放入Whip里，这样一种咖啡加两种调料就融合起来了。<br><img src="http://i12.tietuku.com/0c41d07cbb84eb40.png" alt="current">      </p>
<p>此时它们是这样的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装饰者模式首先有一个超类，是装饰者和被装饰者都继承的，在这个基础上，它们才能利用多态层层嵌套，每一层都是一个装饰者，它们会实现自己的方法为被装饰者添加上一些功能，例如，IO里面，为InputStream添加缓冲。<br>在这里继承不是为了获得行为，而是为了有共同的超类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/05/HeadFirst设计模式笔记-观察者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/05/HeadFirst设计模式笔记-观察者模式/" itemprop="url">HeadFirst设计模式笔记-观察者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-05T22:21:08+08:00">
                2015-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="观察者模式是什么"><a href="#观察者模式是什么" class="headerlink" title="观察者模式是什么"></a>观察者模式是什么</h3><p>HeadFirst设计模式中的定义是：<br>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>举个例子，比如有一家报社，这家报社本身向外提供报纸，但是它只向订阅的人发送报纸。订阅的人就相当于观察者，报社出新报纸，观察者就能看到。当订阅的人取消订阅，报社就不会对其发送报纸。</p>
<h3 id="观察者模式要点"><a href="#观察者模式要点" class="headerlink" title="观察者模式要点"></a>观察者模式要点</h3><ul>
<li>主题（也就是报社）</li>
<li>观察者（也就是订阅的人）</li>
</ul>
<p>观察者模式主要就是由以上两个元素构成的，这两个元素分别实现两个接口。</p>
<ul>
<li><p>Subject    </p>
<p>  这个接口定义被观察者必须实现的职责，它必须能动态的增加删除观察者，还有提醒观察者信息发生改变。</p>
</li>
<li><p>Observer    </p>
<p>  这个接口定义观察者接受消息后，进行update操作，对接受的消息进行处理。</p>
</li>
<li><p>ConcreteSubject</p>
<p>  这是被观察者的具体实现类，实现 Subject 接口中定义的方法，定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。</p>
</li>
<li><p>ConcreteObserver</p>
<p>  这是观察者的实现类，实现 Observer 接口中的方法，处理自己的业务逻辑。</p>
</li>
</ul>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>下面的例子是天气预报，有一个提供天气数据的，是被观察者。监测天气数据并显示在天气预报上的是观察者。<br>首先定义出两个接口：</p>
<p>提供天气数据的接口</p>
<pre><code>public interface Subject {
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();
}
</code></pre><p>观察者接口</p>
<pre><code>public interface Observer {
    public void update(float temperature,float humidity,float pressure);
}
</code></pre><p>显示接口，供观察者实现</p>
<pre><code>public interface DisplayElements {
    public void display();
}
</code></pre><p>实现Subject接口的具体类，相当于提供提供数据的被观察者。</p>
<pre><code>public class WeatherData implements Subject{

private ArrayList observers;
private float temperature;
private float humidity;
private float pressure;

public WeatherData() {
    observers = new ArrayList();
}
@Override
public void notifyObservers() {
    for(int i=0;i&lt;observers.size();i++){
        Observer observer = (Observer) observers.get(i);
        observer.update(temperature,humidity,pressure);
    }
}
public void measurementsChanged(){
    notifyObservers();
}
public void setMeasurements(float temperature,float humidity,float pressure){
    this.temperature = temperature;
    this.humidity = humidity;
    this.pressure = pressure;
    measurementsChanged();
}

@Override
public void registerObserver(Observer o) {
    observers.add(o);
}

@Override
public void removeObserver(Observer o) {
    int i = observers.indexOf(o);
    if(i&gt;0){
        observers.remove(i);
    }
}
}
</code></pre><p> 注意 registerObserver(Observer o)和removeObserver(Observer o)这两个方法，它们的参数都是 Observer 接口，这个在<a href="http://tangyingqi.com/2015/11/05/%E5%85%B3%E4%BA%8EJava%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" target="_blank" rel="noopener">关于Java回调机制及接口的作用</a>这篇文章里面提到过，使用了多态，只要实现了Observer接口的类，都可以传入，然后被注册。这样增强的可扩展性。在上面这段代码中，传入的观察者被添加到ArrayList里，然后在notifyObservers()方法里面调用update()方法。这样，观察者和被观察者之间通过Observer接口就被连接起来了。</p>
<p>实现Observer接口的具体实现类，也就是观察者。</p>
<pre><code>public class CurrentConditionsDisplay implements Observer,DisplayElements{

private float temperature;
private float humidity;
private Subject weatherData;

public CurrentConditionsDisplay(Subject weatherData){
    this.weatherData = weatherData;
    weatherData.registerObserver(this);
}
@Override
public void update(float temperature, float humidity, float pressure) {

    this.temperature = temperature;
    this.humidity = humidity;
    display();
}

@Override
public void display() {
    System.out.println(&quot;Current Conditions:&quot;+temperature+&quot;F degrees and&quot;
                        +humidity+&quot;% humidity&quot;);
}
}
</code></pre><p>上面 WeatherData 被观察者调用update()在这个类实现。</p>
<p>下面是测试类</p>
<pre><code>public class WeatherStation {
public static void main(String[] args) {
    WeatherData weatherData = new WeatherData();
    CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData);
    weatherData.setMeasurements(80, 60, 30.4f);
}
} 
</code></pre><p>结果为：<br>Current Conditions:80.0F degrees and60.0% humidity</p>
<h3 id="Java内部提供的观察者模式"><a href="#Java内部提供的观察者模式" class="headerlink" title="Java内部提供的观察者模式"></a>Java内部提供的观察者模式</h3><p>在Java内部提供了一个类个一个接口来实现观察者模式</p>
<ul>
<li>Observable 类</li>
<li>Observer 接口</li>
</ul>
<p>有两种方式，一种是“拉”，也就是被观察者提供get方法，并且调用 notifyObservers() 这个没有参数的方法。一种是“推”，调用 notifyObservers(Object arg)方法。其实变化也不是很大，只改动了一些部分。看下面代码：</p>
<pre><code>public class WeatherData extends Observable{//继承系统自带的类

private float temperature;
private float humidity;
private float pressure;
WeatherData weatherData;

public WeatherData() {
}

public void measurementsChanged(){
    setChanged();//调用此方法指示状态已改变
    notifyObservers();
}
public void setMeasurements(float temperature,float humidity,float pressure){
    this.temperature = temperature;
    this.humidity = humidity;
    this.pressure = pressure;
    measurementsChanged();
}
//“拉”的方式，提供get方法
public float getHumidity() {
    return humidity;
}
public float getPressure() {
    return pressure;
}
public float getTemperature() {
    return temperature;

}
}
</code></pre><p>观察者类</p>
<pre><code>public class CurrentConditionsDisplay implements Observer,DisplayElements{

Observable observable;//被观察者的引用，用来注册
private float temperature;
private float humidity;

public CurrentConditionsDisplay(Observable observable){
    this.observable = observable;
    observable.addObserver(this);
}

@Override
public void display() {
    System.out.println(&quot;Current Conditions:&quot;+temperature+&quot;F degrees and&quot;
                        +humidity+&quot;% humidity&quot;);
}

@Override
public void update(Observable obs, Object arg) {
    if(obs instanceof WeatherData){
        WeatherData weatherData = (WeatherData) obs;
        this.temperature = weatherData.getTemperature();
        this.humidity = weatherData.getHumidity();
        display();
    }
}
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>自定义的观察者模式，让主题和观察者之间松耦合，它们可以彼此交互，但是不清楚彼此的细节，有新的观察者只需要实现观察者接口，然后注册就能够接受到消息。其实说白了就是定义两个接口，观察者和被观察者实现各自的接口，然后通过观察者接口连接起来。</p>
<p>Java内部提供的方法，省去自己写注册和删除了，提供的“推”和“拉”两种方法。</p>
<p>两种方法各自的缺点：</p>
<p>第一种自己写的方法虽然松耦合，但是它会推送全部信息，无论你想不想要，而且如果增加一条数据，比如体感温度，就要修改每位观察者的调用，而第二种方法只需要修改自身，增加get方法就行了。</p>
<p>使用系统的java.util.Observable(第二种方法)的坏处是，Observable是一个类而不是接口，你必须写一个类继承它，如果想继承其他类就不行了。灵活性太差。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/04/排序算法(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/04/排序算法(一)/" itemprop="url">排序算法(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-04T20:03:24+08:00">
                2015-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是最简单的排序算法。（按从小到大）它是比较相邻两位，如果第 n 位大于 n+1 位，就互换位置。像气泡一样，里面的 for 循环第一次结束，最小的就排在第一位。<br>它的复杂度为O(n*n)，是一种稳定的算法。</p>
<p>下面看它的代码实现：</p>
<pre><code>public class BubbleSort {

public static void main(String[] args) {
    int[] arg = {2,5,3,4,9,1,7};
    bubbleSort(arg);
    for (int i = 0; i &lt; arg.length; i++) {
        System.out.print(arg[i]+&quot;,&quot;);
    }
}
private static void bubbleSort(int[] arg) {

    for(int i=0;i&lt;arg.length;i++){
        for (int j = i+1; j &lt; arg.length; j++) {
            if(arg[i]&gt;arg[j]){
                int temp = arg[i];
                arg[i] = arg[j];
                arg[j] = temp;
            }
        }
    }
}
}
</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>（按从小到大）选择排序第一位首先当成最小值（定义为temp），然后依次比较，如果后一位小于这个最小值，就把这位的值赋给最小值（temp），并记录这一位的下标，里面的for循环结束，交换两个值。<br>它的复杂度为O(n*n)，它是一个不稳定算法，因为如果有重复的元素出现，会破坏稳定性。</p>
<p>下面看实现代码：</p>
<pre><code>public class SelectSort {

public static void main(String[] args) {
    int[] arg = {2,5,3,4,9,1,7};
    selectSort(arg);
    for (int i = 0; i &lt; arg.length; i++) {
        System.out.print(arg[i]+&quot;,&quot;);
    }
}
private static void selectSort(int[] arg) {
    int temp;
    for (int i = 0; i &lt; arg.length; i++) {
        temp = arg[i];
        int smallestLocation = i;
        for (int j = i+1; j &lt; arg.length; j++) { 

            if(arg[j]&lt;temp){
                temp = arg[j];
                smallestLocation = j;
            }
        }
        arg[smallestLocation] = arg[i];
        arg[i] = temp;
    }
}
}
</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序采用分治法。先从要排的数中取出一个数作为基准数（枢轴pivot）一般是第一个数,然后分区，把比它大的数放在右边，比它小的数放在它左边，再对左右区间分区，有点像折半，直到各区间只有一个数。<br>它的复杂度为O(nlogn),如果出现重复元素，在基准数和后面的数交换的时候，容易把前面元素的稳定性打乱。所以它是不稳定的。<br>下面通过实例分析：</p>
<p><img src="http://i5.tietuku.com/d7d1342f9af09f39.png" alt="1"></p>
<p>上面是一列数，首先72作为基准数，把它拿出来，相当于0的位置空出来了。然后从右向左找比72小的数，下标为8的符合，把48放到0的位置。下标为8的位置空出来了，然后从左向右找比72大的数，下标为3符合，放到8的位置，3的位置就空出来了，再从右向左找比72小的数，下标为5符合，放到3的位置。此时，5的位置空了，由于两边汇合到5这一点。把之前的72放到下标为5的地方。<br>这样，72左边的值比它小，右边的值比它大。然后分成左右两个分区重复这一步骤，也就是递归。</p>
<p><img src="http://i5.tietuku.com/20edbfb7adebad20.png" alt="2"></p>
<p>下面看实现的代码：</p>
<pre><code>public class QuickSort {

public static void main(String[] args) {
    int[] arg = {2,5,3,4,9,1,7,55,22,44,66,88,11,15,20,36,54,18,53,645,2};
    quickSort(arg,0,arg.length-1);
    for (int i = 0; i &lt; arg.length; i++) {
        System.out.print(arg[i]+&quot;,&quot;);
    }
}
// l代表左，r代表右
private static void quickSort(int[] arg, int l, int r) {

    if(l&lt;r){
        int i=l,j=r,x=arg[l];
        while(i&lt;j){
            while(i&lt;j &amp;&amp; arg[j]&gt;=x)
                j--;
            if(i&lt;j)
                arg[i++] = arg[j];
            while(i&lt;j &amp;&amp; arg[i]&lt;x)
                i++;
            if(i&lt;j)
                arg[j--] = arg[i];
        }
        arg[i] = x;
        quickSort(arg,l,i-1);
        quickSort(arg,i+1,r);
    }
}
}
</code></pre><p>总结：    </p>
<ul>
<li>i = L(左)，j = R(右)，找到一个基准数，相当于把它拿出来，这个位置就空出来了。</li>
<li>j – 由右向左找比基准数小的数，填入基准数的空位。</li>
<li>i ++ 由左向右找比基准数大的数，填入上一个数的空位。</li>
<li>把基准数放到合适的位置，然后重复上面的步骤。</li>
</ul>
<p>声明：关于快速排序的图片和分析，来自 <a href="http://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">http://blog.csdn.net/morewindows/article/details/6684558</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/04/HeadFirst设计模式笔记-策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/04/HeadFirst设计模式笔记-策略模式/" itemprop="url">HeadFirst设计模式笔记-策略模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-04T20:03:04+08:00">
                2015-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面是我看Head first设计模式的笔记，以前没有看过设计模式相关的书，今天一看发现，设计模式能让你更好的理解关于面向对象，接口，继承，多态。后悔没有早点看，Head first 系列给人非常轻松的感觉，让枯燥的知识显得没那么枯燥，推荐。</p>
<p>我将通过书中的例子，进行梳理。这个例子涵盖了接口，继承，多态的使用，使程序更加灵活。提高代码复用性。利于程序的扩展。</p>
<p>这个例子是关于鸭子的一些行为，鸭子分很多种，这里我分为活鸭子和假鸭子，它们的共同点是都能浮在水上，不同点是，活鸭子叫声是呱呱的，且能飞，玩具鸭子的叫声是吱吱的，不能飞。还有一个不同点就是它们看起来是不一样的。</p>
<p>首先我们用一个接口，定义出飞的行为。</p>
<pre><code>public interface FlyBehavior {
     void fly();
}
</code></pre><p>定义一个类“能飞” 实现飞的行为接口。</p>
<pre><code>public class FlyWithWings implements FlyBehavior{

@Override
public void fly() {
    System.out.println(&quot;i can fly&quot;);
}

}
</code></pre><p>定义一个类“不能飞” 实现飞的行为接口。</p>
<pre><code>public class FlyNoway implements FlyBehavior{

@Override
public void fly() {
    System.out.println(&quot;I can&apos;t fly,i am fake&quot;);
}
}
</code></pre><p>用一个接口定义叫的声音</p>
<pre><code>public interface QuackBehavior {
    void quack();
}
</code></pre><p>定义一个类“呱呱叫” 实现叫的行为接口</p>
<pre><code>public class Quack implements QuackBehavior{

@Override
public void quack() {
    // TODO Auto-generated method stub
    System.out.println(&quot;guagua&quot;);
}

}
</code></pre><p>定义一个类“吱吱叫” 实现叫的行为接口</p>
<pre><code>public class Squeak implements QuackBehavior{

@Override
public void quack() {
    System.out.println(&quot;zhizhi...&quot;);
}
}
</code></pre><p>以上定义了接口和实现类，下面是鸭子的抽象类，是鸭子总有些共同点。</p>
<pre><code>public abstract class Duck {
public abstract void display();//鸭子的样子
public void swim(){
    System.out.println(&quot;i&apos;m swimming&quot;);
}

QuackBehavior quackBehavior;
FlyBehavior flyBehavior;

public void performFly(){
    flyBehavior.fly();
}
public void performQuack(){
    quackBehavior.quack();
}
}
</code></pre><p>现在就可以创建两个鸭子实例了。</p>
<pre><code>public class ToyDuck extends Duck {
public DecoyDuck() {
    flyBehavior = new FlyNoway();
    quackBehavior = new Squeak();
    //接口引用变量在父类中已经创建，可以直接拿来用。
    //这里是多态，可以看到多态和接口组合的灵活性。
}

@Override
public void display() {
    System.out.println(&quot;my body is yellow&quot;);
}
public void performFly(){
    flyBehavior.fly();
}
public void performQuack(){
    quackBehavior.quack();
}
}
</code></pre><p>另一只鸭子</p>
<pre><code>public class RedHeadDuck extends Duck{

public RedHeadDuck() {
    quackBehavior = new Quack();
    flyBehavior = new FlyWithWings();
}

@Override
public void display() {
    System.out.println(&quot;my head is read&quot;);
}
public void performFly(){
    flyBehavior.fly();
}
public void performQuack(){
    quackBehavior.quack();
}
}
</code></pre><p>下面是测试类</p>
<pre><code>public class Test {
public static void main(String[] args) {
    Duck toyDuck = new DecoyDuck();
    toyDuck.performFly();
    toyDuck.performQuack();
    Duck redHeadDuck = new RedHeadDuck();
    redHeadDuck.performFly();
    redHeadDuck.performQuack();
}
}
</code></pre><p>结果：<br>I can’t fly,i am fake<br>zhizhi…<br>i can fly<br>guagua</p>
<h3 id="动态设置行为"><a href="#动态设置行为" class="headerlink" title="动态设置行为"></a>动态设置行为</h3><p>在Duck类里新增方法setFlyBehavior()方法可以动态设置飞的行为。</p>
<pre><code>public void setFlyBehavior(FlyBehavior fb){
    flyBehavior = fb;
}
</code></pre><p>新增一个飞行类，用来测试setFlyBehavior（）。</p>
<pre><code>public class FlyRocketPowered implements FlyBehavior{

@Override
public void fly() {
    System.out.println(&quot;i&apos;m fly with rocket&quot;);
}
}
</code></pre><p>新增一个鸭子类，用来测试</p>
<pre><code>public class ModelDuck extends Duck{

public ModelDuck() {
    flyBehavior = new FlyNoway();
    quackBehavior = new Quack();
}
@Override
public void display() {
    System.out.println(&quot;i&apos;m modelDuck&quot;);
}
}
</code></pre><p>然后是测试</p>
<pre><code>public class Test {
public static void main(String[] args) {
    Duck modelDuck = new ModelDuck();
    modelDuck.setFlyBehavior(new FlyRocketPowered());
    modelDuck.performQuack();
    modelDuck.performFly();
}
}
</code></pre><p>guagua<br>i’m fly with rocket</p>
<p>设计原则：</p>
<ul>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>多用组合，少用继承。</li>
</ul>
<p>针对接口写更多的实现类，效率更高。而针对实现编程，每次实现都要写一堆代码。</p>
<p>以前的做法是，行为来自Duck的超类的具体实现，要不就重写，或是继承某个接口并由子类自行实现，这两种都是依赖于“实现”，这样就被实现绑的死死的，没办法更改行为（除非写更多代码）。在上面的设计中，鸭子的子类将使用接口所表示的行为，所以实际实现不会被绑死在鸭子的子类中。（也就是，特定的具体行为编写在实现了接口的类中。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/04/Java基础知识点回顾(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/04/Java基础知识点回顾(一)/" itemprop="url">Java基础知识点回顾(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-04T20:02:46+08:00">
                2015-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-成员变量和局部变量的区别"><a href="#1-成员变量和局部变量的区别" class="headerlink" title="1.成员变量和局部变量的区别"></a>1.成员变量和局部变量的区别</h3><p>局部变量在一个方法里，必须有初始化值，作用域在方法块内。而成员变量在不需要初始化，作用域在整个类。</p>
<h3 id="2-static关键字的含义"><a href="#2-static关键字的含义" class="headerlink" title="2.static关键字的含义"></a>2.static关键字的含义</h3><p>static可以修饰方法，属性，自由块和内部类。使用static修饰这些成员可以理解成这些成员与类有关，通过“类名.成员”调用，没有static的可以理解成成员与对象相关，需要通过“对象.成员”调用。<br>当static修饰属性时，该属性被多个当前类对象调用，一个对象修改静态属性值后，会影响其他对象。<br>static修饰自由块时，自由块将变成静态自由块，通常用于初始化静态变量。静态自由块只执行一次。</p>
<h3 id="3-变量之间值传递和引用传递的区别"><a href="#3-变量之间值传递和引用传递的区别" class="headerlink" title="3.变量之间值传递和引用传递的区别"></a>3.变量之间值传递和引用传递的区别</h3><ul>
<li>存储机制：简单类型变量是直接在栈内存中开辟存储空间存储变量值。引用类型变量是在引用空间和存储空间两部分构成，引用空间在栈内存中，存储空间在堆内存中，存储空间负责存储变量值，引用空间负责存放存储空间的首地址。</li>
<li>变量传递：引用变量和简单变量都属于值传递，不同的是简单变量传递内容本身，引用变量传递的是引用地址。</li>
</ul>
<h3 id="4-x-y和x-x-y区别，-amp-和-amp-amp-的区别"><a href="#4-x-y和x-x-y区别，-amp-和-amp-amp-的区别" class="headerlink" title="4.x+=y和x=x+y区别，&amp;和&amp;&amp;的区别"></a>4.x+=y和x=x+y区别，&amp;和&amp;&amp;的区别</h3><ul>
<li>+=会自动根据接收变量的类型进行类型的强制转换。</li>
<li>&amp;&amp;的效率更高，当它发现有false就会停止计算，返回false，而&amp;是每个操作数要参与运算。</li>
</ul>
<h3 id="5-和equals-的区别"><a href="#5-和equals-的区别" class="headerlink" title="5.==和equals()的区别"></a>5.==和equals()的区别</h3><ul>
<li>==用于判断两个简单变量的值是否相等，或两个引用变量的引用地址是否相等。</li>
<li>equals()是用于判断引用变量引用地址的存储内容是否相等。</li>
</ul>
<p>举个例子：</p>
<pre><code>int a=1;
int b=1;
system.out.print(a==b);
String c = new String(&quot;tang&quot;);
String d = new String(&quot;tang&quot;);
System.out.print(c==d);
System.out.print(c.equals(d));

true
false
true
</code></pre><h3 id="6-抽象类是什么？"><a href="#6-抽象类是什么？" class="headerlink" title="6.抽象类是什么？"></a>6.抽象类是什么？</h3><p>有些类的方法无法确定具体的实现方式，这是可以将该类定义为抽象类。无法具体实现的方法定义成抽象方法。     </p>
<p>注意：</p>
<ul>
<li>抽象类不能实例化，即不能创建对象，只能作为父类用于被继承。</li>
<li>子类继承一个抽象类后，必须要实现父类中的所有抽象方法，否则子类也要定义为抽象类。</li>
<li>抽象类中可以包含抽象方法，也可以不包含抽象方法。</li>
<li>如果类中包含抽象方法，那么类必须定义为抽象类。</li>
</ul>
<h3 id="7-接口是什么？"><a href="#7-接口是什么？" class="headerlink" title="7.接口是什么？"></a>7.接口是什么？</h3><p>接口是方法声明和常量值定义的集合    </p>
<p>注意:</p>
<ul>
<li>接口只包含方法声明和常量定义，即使定义普通属性，该属性在编译后也将变成常量。</li>
<li>当其他类实现该接口时，接口中所有方法都要求全部实现，否则定义成抽象类。</li>
<li>一个类可以实现多个接口。一个接口可以多继承。</li>
</ul>
<h3 id="8-多态是什么，有什么好处？"><a href="#8-多态是什么，有什么好处？" class="headerlink" title="8.多态是什么，有什么好处？"></a>8.多态是什么，有什么好处？</h3><p>一个父类在某些地方可以代表子类，因此这个父类具有多态性。<br>多态使程序更加灵活，例如ArrayList类中，add方法，参数类型为object，因此可以传递任意类的对象。</p>
<h3 id="9-抽象类和接口的区别"><a href="#9-抽象类和接口的区别" class="headerlink" title="9.抽象类和接口的区别"></a>9.抽象类和接口的区别</h3><ul>
<li>抽象类不能实例化，抽象类既可以包含以实现的方法，也可以包含方法的定义，不具体实现。</li>
<li>接口只包含常量定义和方法定义，接口本身也是一种特殊的抽象类。</li>
<li>抽象类通过继承使用，接口通过实现使用。</li>
<li>抽象类允许实现一个或多个接口</li>
</ul>
<h3 id="10-属性、方法、构造方法、和自由块的调用顺序"><a href="#10-属性、方法、构造方法、和自由块的调用顺序" class="headerlink" title="10.属性、方法、构造方法、和自由块的调用顺序"></a>10.属性、方法、构造方法、和自由块的调用顺序</h3><ul>
<li>父类静态成员和静态初始化块，按在代码中顺序    </li>
<li>子类静态成员和静态初始化块，按在代码中顺序。    </li>
<li>父类实例成员和实例初始化块，按在代码中顺序。    </li>
<li>父类构造方法。    </li>
<li>子类实例成员和实例初始化块，按在代码中顺序。</li>
<li>子类构造方法。</li>
</ul>
<h3 id="11-静态初始化块和非静态初始化块的区别。"><a href="#11-静态初始化块和非静态初始化块的区别。" class="headerlink" title="11.静态初始化块和非静态初始化块的区别。"></a>11.静态初始化块和非静态初始化块的区别。</h3><ul>
<li>非静态初始化块用来初始化一些数据，每次创建对象都调用。</li>
<li>静态初始化块用来初始化静态数据，不管创造多少对象都只调用一次。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/30/怎样做一个新闻客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/30/怎样做一个新闻客户端/" itemprop="url">怎样做一个新闻客户端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-30T15:30:40+08:00">
                2015-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="这篇文章你将看到"><a href="#这篇文章你将看到" class="headerlink" title="这篇文章你将看到"></a>这篇文章你将看到</h3><p>大致了解怎样做一个简单的新闻客户端。</p>
<h3 id="关于这个客户端"><a href="#关于这个客户端" class="headerlink" title="关于这个客户端"></a>关于这个客户端</h3><p>功能：</p>
<ul>
<li>科技新闻</li>
<li>娱乐新闻</li>
<li>设置清除缓存</li>
<li>用户登录注册    </li>
</ul>
<p>我做的这个新闻客户端是获取的 <a href="http://www.jiemian.com/lists/6.html" target="_blank" rel="noopener">界面</a> 的数据，界面的新闻版面非常多，如果完全的做出来工作量太大，所以我只做了科技和娱乐版面。主要用了Jsoup，它的语法很简单，能解析网页的代码，提取需要的数据。用户登录注册只是为了使用Bmob，没什么实际的用处。<br>下面我将尽量还原我是怎样做的这个新闻客户端，希望对你有帮助。</p>
<h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>1.Toolbar+DrawerLayout     </p>
<p>首先是Toolbar+DrawerLayout，可以参考这篇。<a href="http://tangyingqi.com/2015/11/13/Toolbar%20+%20DrawerLayout/" target="_blank" rel="noopener">Toolbar + DrawerLayout</a>         </p>
<p>2.主要内容RecyclerView    </p>
<p>主要的内容显示，用的是 RecyclerView，这个使用起来非常方便，需要导入V7包下的recyclerview。RecyclerView可以通过设置LayoutManager来快速实现listview、gridview和瀑布流的效果。官方自带了动画效果。在RecyclerView中标准化了ViewHolder。需要继承 RecyclerView.ViewHolder。RecyclerView没有提供点击监听，需要在自定义Adapter中自己实现。<br>在Adapter中，加载的布局用到的CardView，是Google官方实现的卡片式的库，每一个item外面都套着一个卡片，使布局清晰美观。    </p>
<p>3.加载数据    </p>
<p>加载数据主要用了Jsoup解析，这是这个客户端的核心所在，Jsoup解析可以解析网页代码，提取你想要的数据，用这个基本可以做任何你想要的客户端。<a href="http://www.open-open.com/jsoup/" target="_blank" rel="noopener">Jsoup Cookbook(中文版)</a>可以看这个学习使用Jsoup。<br>在这里加载数据采用回调的方式，把Volley( <a href="http://tangyingqi.com/2015/10/21/Volley%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">Volley的基本用法解析</a> )获取的网页源代码传到NewsBiz中解析。这样可以自定义解析成功或失败后的处理。关于回调可以看这篇<a href="http://tangyingqi.com/2015/11/05/%E5%85%B3%E4%BA%8EJava%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/" target="_blank" rel="noopener">关于Java回调机制及接口的作用</a><br>Jsoup解析的select()方法挺好用的，但是也要一点点测试，可能是我使用不熟练，解析出我要的数据还是颇费些时间的。需要注意的是，每一条数据要找到外层嵌套标签的类，然后获取其中的数据，要用for循环，new对象要在for循环内，保证数据添加到同一对象内。<br>加载图片我用到了 <a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">universal-image-loader</a> 。这个非常简单易用。</p>
<p>4.清缓存，用户注册登录</p>
<p>通过 <a href="https://github.com/yangfuhai/ASimpleCache" target="_blank" rel="noopener">ASimpleCache</a> 对数据进行缓存，清除缓存的操作引入了别人写的一些类。用户的注册登录使用了Bmob,实现起来非常简单，可以参考 <a href="http://tangyingqi.com/2015/11/10/%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%90%8E%E7%AB%AF%E4%BA%91-Bmob/" target="_blank" rel="noopener">简单易用的后端云——Bmob</a>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我做这个客户端是因为知道了Jsoup解析，这个东西在我刚开始知道的时候感觉非常神奇，因为它几乎可以做任何我想要的客户端。但是缺点是，如果人家官方改代码，你也得改代码。我在做这个期间遇到了很多坑，大部分都解决了，有些还没有，比如我源代码中注释的部分，本来是有一个头条滚动的功能，因为图片不清晰就先删了。有些坑一两天都解决不了，最后发现其实非常简单并解决，这种快感是不言而喻的。<br>我之前也做过一个小东西，叫在读，功能很简单。现在回看，那个代码写的比较乱。这次做这个我才知道，要把那么多的代码更好的组织起来是需要设计模式的，就像积木一样，每个模块测试好，怎样让他们组合起来是我更多考虑的。从思考的问题看来我进步了。<br>希望这篇文章能帮到你，帮你大致构思应该怎样做一个客户端，我的GitHub上面有源码，你可以参照着做自己的客户端，有不懂的问题找我一起探讨。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/13/Toolbar + DrawerLayout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/13/Toolbar + DrawerLayout/" itemprop="url">Toolbar + DrawerLayout</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-13T21:23:14+08:00">
                2015-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇写写现在非常流行的 Toolbar + DrawerLayout。符合 Android Material Design。实现以后是这样的。<br><img src="http://i12.tietuku.com/01a5309c02f8c7d7.png" alt="drawerlayout">    </p>
<h3 id="ToolBar"><a href="#ToolBar" class="headerlink" title="# ToolBar"></a># ToolBar</h3><p>首先为了代码看起来简洁，在 layout 里面新建 toolbar.xml  </p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;

&lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;?attr/colorPrimary&quot;
    android:minHeight=&quot;?attr/actionBarSize&quot;
    android:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;
    app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;
    &gt;

&lt;/android.support.v7.widget.Toolbar&gt;
&lt;/LinearLayout&gt;
</code></pre><p>app 是自定义的，为 toolbar 定义自己的主题，目的是让 Toolbar 上的标题和其他显示为白色。</p>
<h3 id="DrawerLayout"><a href="#DrawerLayout" class="headerlink" title="# DrawerLayout"></a># DrawerLayout</h3><p>同样我们也在 layout 里面自定义 drawerlayout.xml</p>
<pre><code>&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;

android:id=&quot;@+id/dl_left&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;

&lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

   &lt;include layout=&quot;@layout/toolbar&quot;/&gt;

    &lt;FrameLayout
        android:id=&quot;@+id/main_content&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;

&lt;/LinearLayout&gt;

    &lt;android.support.design.widget.NavigationView
        android:id=&quot;@+id/navigation_view&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;start&quot;
        android:background=&quot;@color/white&quot;
        app:menu=&quot;@menu/drawer_menu&quot;
        &gt;
    &lt;/android.support.design.widget.NavigationView&gt;

&lt;/android.support.v4.widget.DrawerLayout&gt;
</code></pre><p>整个LinearLayout 是程序的主界面，首先用 include 表现导入 toolbar 然后创建显示内容的主页面，下面 NavigationView 是系统提供的，需要导入系统提供的库文件。用这个的目的是它可以更灵活的定义 drawerlayout 的界面，通过 addHeaderView() 方法可以插入自定义的布局文件。实现上面红色地方的效果。<br>下面贴出 app:menu=”@menu/drawer_menu” 这个的代码。</p>
<pre><code>&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
&lt;group android:checkableBehavior=&quot;single&quot;&gt;
    &lt;item
        android:id=&quot;@+id/nav_keji&quot;
        android:icon=&quot;@drawable/keji&quot;
        android:checked=&quot;true&quot;

        android:title=&quot;科技&quot; /&gt;
    &lt;item
        android:id=&quot;@+id/nav_yule&quot;
        android:icon=&quot;@drawable/yule&quot;

        android:title=&quot;娱乐&quot; /&gt;
    &lt;item
        android:id=&quot;@+id/nav_settings&quot;
        android:icon=&quot;@drawable/setting&quot;

        android:title=&quot;设置&quot; /&gt;
&lt;/group&gt;
&lt;item android:title=&quot;我的&quot;&gt;
    &lt;menu&gt;
        &lt;item
            android:id=&quot;@+id/nav_personal&quot;
            android:icon=&quot;@drawable/ic_menu_user&quot;
            android:title=&quot;个人信息&quot; /&gt;
        &lt;item
            android:id=&quot;@+id/nav_favorite&quot;
            android:icon=&quot;@drawable/ic_menu_favorite&quot;
            android:title=&quot;我的收藏&quot; /&gt;
    &lt;/menu&gt;
&lt;/item&gt;
&lt;/menu&gt;
</code></pre><p>这个没什么好说的，就是对 Drawerlayout 中菜单项的定义。     </p>
<p>以下是 navigation_header.xml 的代码，这段代码实现了 DrawerLayout 头部的效果。</p>
<pre><code>LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:orientation=&quot;vertical&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;180dp&quot;
android:background=&quot;?attr/colorPrimary&quot;
android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;
&gt;
&lt;View
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;15dp&quot; /&gt;
&lt;LinearLayout
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:gravity=&quot;center&quot;
    android:orientation=&quot;vertical&quot;
    android:padding=&quot;16dp&quot;&gt;

    &lt;ImageView
        android:id=&quot;@+id/navigation_header_view_avatar_iv&quot;
        android:layout_width=&quot;72dp&quot;
        android:layout_height=&quot;72dp&quot;
        android:background=&quot;@mipmap/ic_launcher&quot;
         /&gt;

    &lt;TextView
        android:id=&quot;@+id/navigation_header_view_name_tv&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginTop=&quot;16dp&quot;
        android:text=&quot;未登录&quot;
        android:textAppearance=&quot;@style/TextAppearance.AppCompat.Body1&quot;
        android:textSize=&quot;20sp&quot; /&gt;
&lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code></pre><p>下面贴出主 Activity 的代码</p>
<pre><code>public class MainActivity extends AppCompatActivity {

private Toolbar toolbar;
private DrawerLayout drawerLayout;
private ActionBarDrawerToggle mDrawerToggle;
private NavigationView mNavigationView;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_main);

    initView();
}

private void initView(){

    toolbar = (Toolbar) findViewById(R.id.toolbar);
    mNavigationView = (NavigationView) findViewById(R.id.navigation_view);
    drawerLayout = (DrawerLayout) findViewById(R.id.dl_left);

    toolbar.setTitle(&quot;界面&quot;);

    setSupportActionBar(toolbar);
    toolbar.setNavigationIcon(R.drawable.menu);

    mDrawerToggle = new ActionBarDrawerToggle(this,drawerLayout,toolbar,R.string.open,R.string.close){
        @Override
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
        }

        @Override
        public void onDrawerClosed(View drawerView) {
            super.onDrawerClosed(drawerView);
        }
    };
    drawerLayout.setDrawerListener(mDrawerToggle);

    setupDrawerContent(mNavigationView);
}
private void setupDrawerContent(NavigationView mNavigationView) {

    View header = LayoutInflater.from(this).inflate(R.layout.navigation_header, null);

    mNavigationView.addHeaderView(header);
    mNavigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {
        @Override
        public boolean onNavigationItemSelected(MenuItem menuItem) {
            switch (menuItem.getItemId()){
                case R.id.nav_keji:
                    Toast.makeText(MainActivity.this,&quot;科技&quot;,Toast.LENGTH_SHORT).show();
                    break;
                case R.id.nav_yule:
                    Toast.makeText(MainActivity.this,&quot;娱乐&quot;,Toast.LENGTH_SHORT).show();
                    break;
                case R.id.nav_settings:
                    Toast.makeText(MainActivity.this,&quot;设置&quot;,Toast.LENGTH_SHORT).show();
                    break;
            }
            menuItem.setChecked(true);
            drawerLayout.closeDrawers();
            return true;
        }
    });
}
}
</code></pre><p>上面代码中 ActionBarDrawerToggle 是一个开关，用于打开/关闭 DrawerLayout 抽屉。ActionBarDrawerToggle 提供了一个方便的方式来配合DrawerLayout和ActionBar，以实现推荐的抽屉功能。即点击ActionBar的home按钮，即可弹出DrawerLayout抽屉。 </p>
<h3 id="注意"><a href="#注意" class="headerlink" title="# 注意"></a># 注意</h3><p>使用 Toolbar 要使用 NoActionBar 的主题，如果想要把 Toolbar 上的字变为白色，需为 Toolbar自定义 dark 的主题。</p>
<p>这篇贴了一堆代码，因为实在没什么好说的，代码都很简单。如果有什么疑问，可以找我讨论。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/10/Serializable和Parcelable传递值对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/10/Serializable和Parcelable传递值对象/" itemprop="url">Serializable和Parcelable传递值对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-10T15:35:58+08:00">
                2015-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="# 前言"></a># 前言</h3><p>这篇是关于传递值对象，在两个Activity中间，或者Fragment和Activity之间传递值对象，有两种方法，一种是实现Serializable,另一种是实现Parcelable。   </p>
<p>区别：    </p>
<p>1.在使用内存的时候，Parcelable 类比Serializable性能高，所以推荐使用Parcelable类。</p>
<p>2.Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。  </p>
<p>3.Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点， 也不提倡用，但在这种情况下，还是建议你用Serializable 。</p>
<h3 id="Demo演示"><a href="#Demo演示" class="headerlink" title="# Demo演示"></a># Demo演示</h3><h4 id="1-实现Serializable"><a href="#1-实现Serializable" class="headerlink" title="1.实现Serializable"></a>1.实现Serializable</h4><p>这个 Demo 在主Activity里面有一个 button ，点击打开另一个Activity并传递值对象。另一个Activity里面有一个TextView用来显示传递过来的数据。</p>
<pre><code>public class User implements Serializable{

private String name;

public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}

}
</code></pre><p>创建 User 类，自定义一些属性，实现Serializable接口。</p>
<pre><code>public class MainActivity extends Activity {
private Button btn;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    btn = (Button) findViewById(R.id.btn_start);
    final User user = new User();
    user.setName(&quot;tang&quot;);
    btn.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {

            Intent intent = new Intent(MainActivity.this,Another.class);
            //Bundle bundle = new Bundle();
            //bundle.putSerializable(&quot;name&quot;, user);
            //intent.putExtras(bundle);
            intent.putExtra(&quot;name&quot;, user);
            startActivity(intent);
        }
    });
}
}
</code></pre><p>主Activity，这里有两种方法,注释里这种方法，创建Bundle，能传递更多的数据。</p>
<pre><code>public class Another extends Activity{
private TextView tv;

@Override
protected void onCreate(Bundle savedInstanceState) {
    // TODO Auto-generated method stub
    super.onCreate(savedInstanceState);
    setContentView(R.layout.another);
    tv = (TextView) findViewById(R.id.tv_name);
    Bundle bundle = getIntent().getExtras();
    if(bundle!=null){

      //User user = (User) getIntent().getSerializableExtra(&quot;name&quot;);
        User user = (User) bundle.getSerializable(&quot;name&quot;);
        tv.setText(user.getName().toString());
    }
}
}
</code></pre><p>以上，就是实现Serializable传递值对象，非常简单。</p>
<h4 id="2-实现Parcelable"><a href="#2-实现Parcelable" class="headerlink" title="2.实现Parcelable"></a>2.实现Parcelable</h4><p>这个跟上面的基本差不多，只是User类里面多了一些需要实现的方法。</p>
<pre><code>public class User implements Parcelable{

private String name;

public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}    
//必须是 public static final，且 CREATOR 是大写
public static final Parcelable.Creator&lt;User&gt; CREATOR = new Creator&lt;User&gt;() {

    @Override
    public User createFromParcel(Parcel source) {
        User user = new User();
        user.name = source.readString();
        return user;
    }

    @Override
    public User[] newArray(int size) {
        return new User[size];
    }
};
//这个方法基本不用管，内容描述接口
@Override
public int describeContents() {
    return 0;
}
@Override
public void writeToParcel(Parcel parcel, int flags) {

    parcel.writeString(name);

}
}
</code></pre><p>User类里面多了三个方法。可以把 Parcelable 看成流，先 writeToParcel 写入流中，然后再从流中读取，返回给逻辑层。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/10/简单易用的后端云-Bmob/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/10/简单易用的后端云-Bmob/" itemprop="url">简单易用的后端云——Bmob</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-10T10:40:46+08:00">
                2015-11-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天知道了一个新东西，Bmob， 它是别人搭建好的后端，我们可以直接使用它来存储一些数据，例如App中的注册的用户数据。用起来非常简单方便。<br>它的官方网站：<a href="http://www.bmob.cn/" target="_blank" rel="noopener">http://www.bmob.cn/</a><br>通过这个网站里面的教学，你就能学会，所以我这篇只是一个记录。<br>使用步骤：<br>1.在它的官网下载Sdk，导入到自己的工程中。<br>2.添加权限  </p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_LOGS&quot;/&gt;      
</code></pre><p>3.初始化Bmob</p>
<pre><code>public class MainActivity extends Activity {
@Override
protected void onCreate(Bundle savedInstanceState) {
     // TODO Auto-generated method stub
    super.onCreate(savedInstanceState);
     // 初始化 Bmob SDK
    // 使用时请将第二个参数Application ID替换成你在Bmob服务器端创建的Application ID
    Bmob.initialize(this, &quot;Your Application ID&quot;);
}
} 
</code></pre><p><img src="http://i13.tietuku.com/6815725f4af3b9ed.png" alt="ID"><br>下面我通过一个实例来演示一下它的用法</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot;
   tools:context=&quot;.MainActivity&quot;&gt;

   &lt;EditText
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:id=&quot;@+id/et_name&quot;
   android:inputType=&quot;text&quot;
   android:padding=&quot;10dp&quot;
   /&gt;
&lt;EditText
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:id=&quot;@+id/et_password&quot;
    android:inputType=&quot;textPassword&quot;
    android:padding=&quot;10dp&quot;/&gt;
&lt;Button
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:id=&quot;@+id/btn_login&quot;
    android:text=&quot;登录&quot;/&gt;
&lt;Button
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:id=&quot;@+id/btn_reg&quot;
    android:text=&quot;注册&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>主Activity的布局文件中两个输入框，分别是用户名密码，两个按钮，分别是登录和注册。</p>
<pre><code>public class User extends BmobUser {
private String info;

public String getInfo() {
    return info;
}

public void setInfo(String info) {
    this.info = info;
}
}
</code></pre><p>这是实体类，要继承 BmobUser 这里面可以自定义一些它提供的表里没有的字段。</p>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {
private EditText et_name,et_password;
private Button btn_login,btn_reg;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Bmob.initialize(this, &quot;d765b030daa3803100e65fa7ad0f463b&quot;);
    initView();
}

private void initView() {
    et_name = (EditText) this.findViewById(R.id.et_name);
    et_password = (EditText) this.findViewById(R.id.et_password);
    btn_login = (Button) this.findViewById(R.id.btn_login);
    btn_reg = (Button) this.findViewById(R.id.btn_reg);
    btn_login.setOnClickListener(this);
    btn_reg.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    switch (v.getId()){
        case R.id.btn_login:
            User user = new User();
            user.setInfo(&quot;BmobDemo&quot;);
            user.setUsername(et_name.getText().toString().trim());
            user.setPassword(et_password.getText().toString().trim());
            user.login(this, new SaveListener() {
                @Override
                public void onSuccess() {
                    Toast.makeText(MainActivity.this,&quot;success&quot;,Toast.LENGTH_SHORT).show();
                }

                @Override
                public void onFailure(int i, String s) {
                    Toast.makeText(MainActivity.this,&quot;fail:&quot;+s,Toast.LENGTH_SHORT).show();
                }
            });
            break;
        case R.id.btn_reg:
            Intent intent = new Intent(MainActivity.this,RegActivity.class);
            startActivity(intent);
    }
}
}
</code></pre><p>在主Activity里面，点击登录按钮，它会验证用户信息。点击注册按钮，会跳转到注册页。</p>
<pre><code>public class RegActivity extends Activity implements View.OnClickListener{
private EditText et_name,et_password;
private Button btn_login,btn_reg;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.reg_activity);
    initView();
}
private void initView() {
    et_name = (EditText) this.findViewById(R.id.et_name);
    et_password = (EditText) this.findViewById(R.id.et_password);
    btn_login = (Button) this.findViewById(R.id.btn_login);
    btn_reg = (Button) this.findViewById(R.id.btn_reg);
    btn_login.setOnClickListener(this);
    btn_reg.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    switch (v.getId()) {
        case R.id.btn_login:
            Intent intent = new Intent(RegActivity.this,MainActivity.class);
            startActivity(intent);
            break;
        case R.id.btn_reg:
            User user = new User();
            user.setInfo(&quot;reg&quot;);
            user.setUsername(et_name.getText().toString().trim());
            user.setPassword(et_password.getText().toString().trim());
            user.signUp(this, new SaveListener() {
                @Override
                public void onSuccess() {
                    Toast.makeText(RegActivity.this,&quot;reg success&quot;,Toast.LENGTH_SHORT).show();
                }

                @Override
                public void onFailure(int i, String s) {
                    Toast.makeText(RegActivity.this,&quot;reg fail&quot;+s,Toast.LENGTH_SHORT).show();
                }
            });
            break;
    }
}
}
</code></pre><p>注册页的布局文件跟登录页是一样的，就不贴了，在这里注册后可以看到数据已经被存储到后端云里了。<br><img src="http://i13.tietuku.com/2fd2c66ae0e4fb85.png" alt="记录"><br>经过这些简单的步骤就是先了注册登录功能，它还有其他的功能你可以去官网教学里去看。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/05/关于Java回调机制及接口的作用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/05/关于Java回调机制及接口的作用/" itemprop="url">关于Java回调机制及接口的作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-05T16:54:12+08:00">
                2015-11-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="源起"><a href="#源起" class="headerlink" title="#源起"></a>#源起</h3><p>昨天开始研究java的回调机制，觉得很复杂，调来调去，想不明白。看了很多文章，经过一晚上的沉淀，在梦里解决了这个问题，早上醒来觉得一切都清晰了，还搞明白了一直有点模糊的接口是干什么用的。所以建议老师讲接口的时候，应该讲讲回调机制。</p>
<p>下面我来记录下我是怎样思考这个问题的。</p>
<p>首先我看到了这篇Blog,对我理解帮助很大，下面的例子也是基于这篇Blog的。<br><a href="http://blog.csdn.net/xiaanming/article/details/17483273" target="_blank" rel="noopener">http://blog.csdn.net/xiaanming/article/details/17483273</a></p>
<h3 id="类比举例"><a href="#类比举例" class="headerlink" title="#类比举例"></a>#类比举例</h3><h6 id="1-实现接口回调"><a href="#1-实现接口回调" class="headerlink" title="1.实现接口回调"></a>1.实现接口回调</h6><p>理解复杂概念最好的方法就是做类比，好的类比能让你更快的理解。下面这个例子是，小李问小王一个问题（1+1=？），小王来回答他。这就是一个简单的回调。下面我们来看这个例子：</p>
<pre><code>public interface Callback {
    //这个就是回调方法
    public void result(String answer);
}
</code></pre><p>首先我们需要一个接口，这个接口的作用后面再说。</p>
<pre><code>public class Li implements Callback{
  //小王的引用
  private Wang wang;
  //问题的定义
  String problem = &quot;1+1 = ?&quot;;

  public Li(Wang wang){
     this.wang = wang;
  }
 //回调方法
  public void result(String answer) {
      System.out.println(&quot;answer is :&quot;+answer);
  }
  //问问题的方法
  public void ask(){
     wang.execute(this, problem);
  }
}
</code></pre><p>这是问问题的小李的类，里面有小王的引用，问题的定义，回调方法，和问问题的方法。回调方法是实现接口里面定义的方法。</p>
<pre><code>public class Wang {
    //这是一个关键的问题，Callback的引用
    public void execute(Callback callback,String problem){
        System.out.println(problem);
        try {
            //这里表示小王思考了2秒
            new Thread().sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String answer = &quot;2&quot;;
        //调用回调方法
        callback.result(answer);
    }
}
</code></pre><p>这是解决问题的小王的类，标注着关键问题的地方是我一开始想不明白的地方，为什么传入Callback的引用，其实这里传入的是小李的引用，这样才能调用小李的result（）方法。 Callback callback，这样写正是接口的妙用，小李实现了接口，接口相当于抽象类，也就相当于，小李继承了抽象类，所以写成Callback callback，可以传入小李，小明，或者任何实现了Callback接口的人（多态）。这样程序就有了普适性，灵活性。<br>反过来想，如果没有接口会怎样？不实现Callback接口，上面的功能也能实现，只不过要把Callback callback 改成 Li li ， 这样的话，小王就只能解决小李的问题，不能解决其他人的问题了。</p>
<pre><code>public class Test {
    public static void main(String[] args) {

        Li li = new Li(new Wang());
        li.ask();
    }
}
//运行结果
 ----&gt; 1+1 = ?
 ----&gt; answer is :2
</code></pre><p>这是测试类。</p>
<h6 id="2-更常见的回调形式"><a href="#2-更常见的回调形式" class="headerlink" title="2.更常见的回调形式"></a>2.更常见的回调形式</h6><p>上面是实现接口的回调，在开发中，更常见的是不实现接口，直接传入callback对象和实现，其实没太大区别，但是初学者看起来还是会发蒙。举个例子，还是上面的代码，只需要修改一些地方。</p>
<pre><code>public class Li {

private Wang wang;

String problem = &quot;1+1 = ?&quot;;

public Li(Wang wang){
    this.wang = wang;
}
public void ask(){
    wang.execute(new Callback(){
        public void result(String answer){
            System.out.println(&quot;answer is :&quot;+answer);
        }
    }, problem);
}
}
</code></pre><p>这里的小李没有实现Callback接口，接口不能实例化，所以直接传入接口的引用和实现。</p>
<h6 id="3-Android中Button的回调"><a href="#3-Android中Button的回调" class="headerlink" title="3.Android中Button的回调"></a>3.Android中Button的回调</h6><p>下面结合Android中的Button来理解一下。</p>
<pre><code>//这是回调接口
   public interface OnClickListener {  
    //回调方法
    void onClick(View v);  
}  
</code></pre><p>下面这个类相当于小李。</p>
<pre><code>public class MainActivity extends Activity implements OnClickListener{  

//对Button的引用，相当于上面的小李对小王的引用。
private Button button;  

@Override  
public void onCreate(Bundle savedInstanceState) {  
    super.onCreate(savedInstanceState);  
    setContentView(R.layout.activity_main);  
    button = (Button)findViewById(R.id.button1);  
    //相当于上面小李调用小王的方法，传入自己的引用
    button.setOnClickListener(this);  
}  

//回调方法，做自己的实现
@Override  
public void onClick(View v) {  
    Toast.makeText(getApplication(), &quot;OnClick&quot;, Toast.LENGTH_LONG).show();  
}  
</code></pre><p>下面这个类相当于小王，是View类的setOnClickListener方法    </p>
<pre><code>public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {  

protected OnClickListener mOnClickListener;  


// 这相当于上面的小王的execute（）方法
public void setOnClickListener(OnClickListener l) {  
    if (!isClickable()) {  
        setClickable(true);  
    }  
    mOnClickListener = l;  
}  

public boolean performClick() {  
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  

    if (mOnClickListener != null) {  
        playSoundEffect(SoundEffectConstants.CLICK);  

        // 这个是回调方法 
        mOnClickListener.onClick(this);  
        return true;  
    }  

    return false;  
}  
}   
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="#总结"></a>#总结</h3><p>我们来总结一下回调方法都需要什么或者说共同点：  </p>
<p>1.一个接口C，接口里面有回调方法</p>
<p>2.一个A类（发出请求解决问题的类，自定义类）： </p>
<ul>
<li>实现接口C  </li>
<li>实现接口C中的回调方法</li>
<li>有B类的引用</li>
<li>调用B类的方法，传入自身的引用</li>
</ul>
<p>3.一个B类（解决问题的类）： 解决问题的方法参数里面有接口的引用，方便传入A类，然后利用传入的引用调用回调方法。 </p>
<hr>
<ul>
<li>回调机制什么时候用：  </li>
</ul>
<p>在执行一个任务，不知道具体什么时候执行，在某一特定时候触发才执行，想想Button。   </p>
<ul>
<li>回调机制什么好处： </li>
</ul>
<p>程序变成异步的了，你不必等待什么时候调用这个函数，也不必知道，再此期间你可以做别的事，等待被触发，就相当于把问题交给别人，让他帮你做。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
