<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Tangyingqi&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Tangyingqi&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tangyingqi&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Tangyingqi's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tangyingqi's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/05/Volley + Gson 获取网络数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/05/Volley + Gson 获取网络数据/" itemprop="url">Volley + Gson 获取网络数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-05T18:12:26+08:00">
                2016-10-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在百度上看到了查询城市公交车的Api接口，所以想写一个App，只写了一点试试获取数据，用到了 Volley + Gson  的方式拿到数据，写在这里做一个总结。</p>
<p><a href="http://apistore.baidu.com/apiworks/servicedetail/1697.html" target="_blank" rel="noopener">http://apistore.baidu.com/apiworks/servicedetail/1697.html</a></p>
<h3 id="需要用到的"><a href="#需要用到的" class="headerlink" title="需要用到的"></a>需要用到的</h3><p>首先需要导入 Volley 和 Gson 的库</p>
<p><a href="https://github.com/google/gson" target="_blank" rel="noopener">https://github.com/google/gson</a></p>
<p><a href="http://download.csdn.net/detail/sinyu890807/7152015" target="_blank" rel="noopener">http://download.csdn.net/detail/sinyu890807/7152015</a></p>
<p>既然要访问网络，不要忘了添加网络权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2016/10/05/Volley + Gson 获取网络数据/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/18/高性能的数据库框架-greenDAO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/18/高性能的数据库框架-greenDAO/" itemprop="url">高性能的数据库框架-greenDAO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-18T15:59:10+08:00">
                2015-12-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于greenDAO"><a href="#关于greenDAO" class="headerlink" title="关于greenDAO"></a>关于greenDAO</h3><p>greenDAO是一个将对象映射到SQLite数据库中的轻量且快速的ORM解决方案，它性能是目前最好的，且内存开销小。其他框架因为注解的原因，性能不如greenDAO。</p>
<h3 id="使用greenDAO"><a href="#使用greenDAO" class="headerlink" title="使用greenDAO"></a>使用greenDAO</h3><p>一.在Android工程中配置GreenDao Generator</p>
<p>在main目录下新建一个目录java-gen,用于存放greenDAO自动生成的Bean、Dao、DaoMaster、DaoSession</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967488134646.png" alt=""></p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967488110019.png" alt=""></p>
<p>配置build.gradle</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967489561349.png" alt=""></p>
<p>在Android里面添加如下代码</p>
<pre><code>sourceSets{
    main{
        java.srcDirs =[&apos;src/main/java&apos;,&apos;src/main/java-gen&apos;]
    }
}
</code></pre><p>在dependencies里面添加如下代码</p>
<pre><code>compile &apos;de.greenrobot:greendao:1.3.7&apos;
</code></pre><p>二.新建GreenDao Generator模块，新建Module</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967489104631.png" alt=""></p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967490104007.png" alt=""></p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967490123204.png" alt=""></p>
<p>配置daoexamplegenerator 工程的build.gradle,添加dependencies</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967491833654.png" alt=""></p>
<p>编写自动生成的DaoGenerator类，我的是MyDaoGenerator，这个名字可以自己起，在创建的时候，最好不要用DaoGenerator这个名字，会有冲突。</p>
<pre><code>public class MyDaoGenerator {

public static void main(String[] args)throws Exception{
    //两个参数分别代表：数据库版本号，自动代码生成所在的包名
    Schema schema = new Schema(1,&quot;com.tyq.greendao&quot;);

    addData(schema);

    //使用DaoGenerator的generateAll方法自动生成代码，会放入第二个参数的路径中
    new DaoGenerator().generateAll(schema,&quot;/Android Sample/AccountBook/app/src/main/java-gen&quot;);

}

private static void addData(Schema schema){
    //一个实体类就代表一张表，此处表名为Person
    Entity person = schema.addEntity(&quot;Person&quot;);

    //生成表的字段
    person.addIdProperty();
    person.addStringProperty(&quot;name&quot;);
    person.addStringProperty(&quot;money&quot;);
}
}
</code></pre><p>经过上面的步骤，你可以执行generator工程，如果一切都对了，会在java-gen里生成四个类文件，并且控制台会看到如下</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967491555755.png" alt=""></p>
<p>下面你就可以在自己的工程中使用greenDao了，在使用GreenDao的时候，你需要先做一些初始化的操作。</p>
<pre><code>private void setUpDatabase() {
    //通过DaoMaster的内部类DevOpenHelper，可以获得一个SqliteOpenHelper对象
    //注意：默认的DaoMaster.DevOpenHelper会在数据库升级时，删除所有表
    DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;person-db&quot;, null);

    db = helper.getWritableDatabase();

    daoMaster = new DaoMaster(db);
    daoSession = daoMaster.newSession();

}

private PersonDao getPersonDao() {
    return daoSession.getPersonDao();
}
</code></pre><ul>
<li>DaoMaster:</li>
</ul>
<p>daomaster以一定模式持有数据库对象(SQLiteDatabase)，并管理一些Dao类，有一个静态方法创建和drop数据库表，它的内部类OpenHelper和DevOpenHelper是SQLiteOpenHelper的实现类，用于创建SQLite数据库的模式。</p>
<ul>
<li>DaoSession：</li>
</ul>
<p>管理指定模式下所有可用的DAO对象，你可以通过某个get方法获取到。DaoSession提供一些通用的持久化方法，比如对实体进行插入，加载，更新，刷新和删除。</p>
<p>在其他地方调用getPersonDao()就可以使用增删改查了。</p>
<pre><code>getPersonDao().insert(person);//插入
getPersonDao().deleteByKey(id);//删除
list = getPersonDao().queryBuilder()
.where(PersonDao.Properties.Name.like(&quot;%&quot; + et_search_name.getText().toString() + &quot;%&quot;))
.list();//查询
</code></pre><p>查询需要注意，返回的是List，我在适配数据的时候，自己写了一个适配器，把list传过去，然后设置。</p>
<p>模糊查询跟SQLite一样，可以加 % 控制，调用like()方法。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我第一个写的小App就是用Sqlite简单的增删改查，非常简单，最近学习了GreenDao，就把他重写了一遍，放在GitHub上了，有兴趣的可以去看看。</p>
<p>参考文章：</p>
<ul>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0727/3223.html" target="_blank" rel="noopener">ORM 框架之 greenDAO 使用心得</a></li>
<li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1127/2069.html" target="_blank" rel="noopener">GreenDao官方文档翻译</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/16/HeadFirst设计模式笔记-代理模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/16/HeadFirst设计模式笔记-代理模式/" itemprop="url">HeadFirst设计模式笔记-代理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-16T16:24:00+08:00">
                2015-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3><p>定义：代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>
<p>简单的说，代理类相当于一个中介，要接触被代理类，需要通过代理类。代理类里面会有被代理类的引用，通过引用调用被代理类中的方法。在代理类里可以加一些方法进行控制。可以想想装饰者模式来理解，它们都是为一个类包装上一些东西。下面会说两者的不同。</p>
<p><img src="http://i4.tietuku.com/f2115338723153fd.png" alt="代理模式"></p>
<ul>
<li>Subject：抽象主题类，它可以是接口也可以是抽象类，被代理类和代理类都要实现此接口。</li>
<li>RealSubject：具体主题类，也是被代理类，是业务逻辑的具体执行者。</li>
<li>ProxySubject：代理主题类，它里面有被代理类的引用，以完成具体主题的业务逻辑。</li>
</ul>
<h3 id="为什么使用代理模式"><a href="#为什么使用代理模式" class="headerlink" title="为什么使用代理模式"></a>为什么使用代理模式</h3><p>有些对象由于某些原因(比如对象创建开销大，或者某些操作需要安全控制，或者需要进程外的额外访问)，直接访问给系统结构带来很多麻烦。我们会在访问此对象的时候加上一个对此对象的访问层。</p>
<p>例如，图片加载这种耗时操作可以放在代理类里，或者，有些用户权限不允许修改删除，可以在代理类里加以控制。</p>
<p>实际中的代理模式：Windows里面的快捷方式，买东西会去店里而不是工厂。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>这个例子是关于图片处理</p>
<p>首先定义一个统一接口</p>
<pre><code>public interface Image {
    public void display();
}
</code></pre><p>具体主题类</p>
<pre><code>public class RealImage implements Image{

    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk(filename);
    }

    private void loadFromDisk(String filename) {
        System.out.println(&quot;Loading &quot; + filename);
    }

    @Override
    public void display() {
        System.out.println(&quot;display &quot;+ filename);
    }
}
</code></pre><p>代理类</p>
<pre><code>public class ProxyImage implements Image{

    private String filename;
    RealImage realImage;
    public ProxyImage(String filename) {
        this.filename = filename;
    }
    @Override
    public void display() {
        if(realImage==null){
            realImage = new RealImage(filename);
        }
        realImage.display();
    }
}
</code></pre><p>测试类</p>
<pre><code>public class Test {
    public static void main(String[] args) {
        Image image = new ProxyImage(&quot;test.jpg&quot;);
        image.display();
    }
}
</code></pre><p>结果：</p>
<pre><code>Loading test.jpg
display test.jpg
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代理模式是使用中间人做一些操作，它挡在对象的前面，并负责把请求转发给它们。它跟装饰者模式的不同之处是意图不同，装饰者是给对象添加装饰，也就是增加行为，而代理模式是给对象增加控制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/15/HeadFirst设计模式笔记-状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/15/HeadFirst设计模式笔记-状态模式/" itemprop="url">HeadFirst设计模式笔记-状态模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-15T15:46:36+08:00">
                2015-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是状态模式"><a href="#什么是状态模式" class="headerlink" title="什么是状态模式"></a>什么是状态模式</h3><p>定义：状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p>简单的说就是把状态封装成单独的类，并将动作委托到代表当前状态的对象</p>
<p><img src="http://i12.tietuku.com/9e0372ee7183a393.png" alt="类图"></p>
<p>上面的就是状态模式的类图，它跟策略模式很像，可以回想策略模式来理解状态模式。它们都是通过对象的组合实现动态的改变行为。</p>
<h3 id="什么时候使用状态模式"><a href="#什么时候使用状态模式" class="headerlink" title="什么时候使用状态模式"></a>什么时候使用状态模式</h3><p>不使用状态模式的时候，我们会定义一些静态变量，为这些变量赋值不同的数字，来表示各个状态。这样的方法如果需要增加状态是非常不方便的。状态模式可以使状态之间解耦，可以随时创建新的状态，只要实现共同的接口。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>下面这个例子是关于自动售卖机的，它有如下几个状态</p>
<ul>
<li>没投币</li>
<li>已投币</li>
<li>售罄</li>
<li>投币之后出货状态</li>
</ul>
<p>这些状态都有统一的接口，实现统一的方法，只是实现各有不同。然后通过setState()方法动态的转换状态。</p>
<p>下面是统一的接口</p>
<pre><code>public interface State {
    public void insertQuarter();//投币
    public void ejectQuarter();//退币
    public void turnCrank();//摇杆
    public void dispense();//出货
}    
</code></pre><p>没币的状态</p>
<pre><code>public class NoQuarterState implements State{

    GumballMachine gumballMachine;

    public NoQuarterState(GumballMachine gumballMachine){
        this.gumballMachine = gumballMachine;
    }

    @Override
    public void dispense() {
        System.out.println(&quot;You need to pay fitst&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;You haven&apos;t inserted a quarter&quot;);
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You inserted a quarter&quot;);
        gumballMachine.setState(gumballMachine.getHasQuarterState());
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned,but there&apos;s no quarter&quot;);
    }
}
</code></pre><p>有币的状态</p>
<pre><code>public class HasQuarterState implements State{

    GumballMachine gumballMachine;
    public HasQuarterState(GumballMachine gumballMachine){
        this.gumballMachine = gumballMachine;
    }
    @Override
    public void dispense() {
        //System.out.println(&quot;No gumball dispensed&quot;);
        //这个方法在这里没什么用
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;Quarter returned&quot;);
        gumballMachine.setState(gumballMachine.getSoldState());
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;You can&apos;t insert another quarter&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;You turned...&quot;);
        gumballMachine.setState(gumballMachine.getSoldState());
    }

}
</code></pre><p>售罄状态</p>
<pre><code>public class SoldOutState implements State{

    GumballMachine gumballMachine;
    public SoldOutState(GumballMachine gumballMachine){
        this.gumballMachine = gumballMachine;
    }
    @Override
    public void dispense() {
        System.out.println(&quot;Sorry,no gumballs dispense&quot;);
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;Sorry,You can&apos;t eject,you haven&apos;t inserted a quarter yet&quot;);

    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;Sorry,you can&apos;t insert a quarter,the machine is sold out&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;Sorry,there are no gumballs&quot;);
    }
}
</code></pre><p>出货状态</p>
<pre><code>public class SoldState implements State{

    GumballMachine gumballMachine;
    public SoldState(GumballMachine gumballMachine){
        this.gumballMachine = gumballMachine;
    }
    @Override
    public void dispense() {
        gumballMachine.releaseBall();
        if(gumballMachine.getCount()&gt;0){
            gumballMachine.setState(gumballMachine.getNoQuarterState());
        }else{
            System.out.println(&quot;Oops,out of gumballs&quot;);
            gumballMachine.setState(gumballMachine.getSoldOutState());
        }
    }

    @Override
    public void ejectQuarter() {
        System.out.println(&quot;you already turned the crank&quot;);
    }

    @Override
    public void insertQuarter() {
        System.out.println(&quot;please wait,we&apos;re already giving you a gumball&quot;);
    }

    @Override
    public void turnCrank() {
        System.out.println(&quot;Turning twice doesn&apos;t get you another gumball&quot;);
    }
}
</code></pre><p>售卖机的类</p>
<pre><code>public class GumballMachine {

    State noQuarterState;
    State hasQuarterState;
    State soldState;
    State soldOutState;

    State state = soldOutState;
    int count = 0;

    public GumballMachine(int numberGumballs) {
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);
        soldOutState = new SoldOutState(this);
        this.count = numberGumballs;
        if(numberGumballs&gt;0){
            state = noQuarterState;
        }
    }

    public void setState(State state) {
        this.state = state;
    }
    public void insertQuarter(){
        state.insertQuarter();
    }
    public void ejectQuarter(){
        state.ejectQuarter();
    }
    public void turnCrank(){
        state.turnCrank();
        state.dispense();
    }

    public void releaseBall(){
        System.out.println(&quot;A gumball comes rolling out the slot...&quot;);
        if(count!=0){
            count = count-1;
        }
    }

    public State getNoQuarterState() {
        return noQuarterState;
    }

    public State getHasQuarterState() {
        return hasQuarterState;
    }

    public State getSoldState() {
        return soldState;
    }

    public State getSoldOutState() {
        return soldOutState;
    }

    public int getCount() {
        return count;
    }
}
</code></pre><p>售卖机类里持有所有状态的引用，内部转换状态通过setState()方法，然后通过被动态设置的state调用相应的方法。</p>
<p>测试类</p>
<pre><code>public class GumballMachineTest {
    public static void main(String[] args) {
        GumballMachine gumballMachine = new GumballMachine(5);
        gumballMachine.insertQuarter();
        gumballMachine.turnCrank();
        gumballMachine.insertQuarter();
        gumballMachine.ejectQuarter();
        gumballMachine.ejectQuarter();
    }
}
</code></pre><p>结果：</p>
<pre><code>You turned...
A gumball comes rolling out the slot...
You inserted a quarter
Quarter returned
you already turned the crank
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过策略模式理解状态模式就很好理解了，它们基本是一样的，只是意图不同。那么，它们究竟是怎么的不同，怎么区分它们。<br>策略模式要做的是定义一些策略，让他的对象去使用。想想鸭子那个例子，它让那些行为组合起来表示的是一个整体，一只完整的鸭子。而鸭子的属性是固定的，被固定好就不会改变。而状态模式定义的就是一些状态，它会随时动态的改变，也就是说，使用状态模式就是要不断的改变行为，这是它的初衷。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/14/HeadFirst设计模式笔记-组合模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/14/HeadFirst设计模式笔记-组合模式/" itemprop="url">HeadFirst设计模式笔记-组合模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-14T22:10:40+08:00">
                2015-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是组合模式"><a href="#什么是组合模式" class="headerlink" title="什么是组合模式"></a>什么是组合模式</h3><p>定义：组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及个别对象组合。</p>
<p>简单的说，组合模式就是一个树形结构，根节点就是一个通用的接口，这个接口可以定义一些通用方法。下面是子节点，子节点还可以有自己的子节点。所有节点都实现同一接口。就像一个文件夹里面有文件也有其他文件夹。</p>
<p><img src="http://i4.tietuku.com/65c621d1920514d6.png" alt="树"></p>
<p><img src="http://i4.tietuku.com/f5e1a2e80880b832.png" alt="类图"></p>
<ul>
<li>主要解决：它在我们树形结构问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样处理复杂元素，从而使客户程序与复杂程序内部结构解耦。</li>
<li>关键代码：树枝内部组合该接口，并且含有内部属性List，里面放Component</li>
<li>优点：1.高层模块调用简单。2.节点自由增加。</li>
<li>缺点：在使用组合模式时，其叶子和树枝都是实现类，而不是接口，违反了依赖倒置原则。</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>员工下面有领导和普通员工，领导有上层领导，也有下层员工。</p>
<p>首先是一个公用接口</p>
<pre><code>public interface Employee {
    public void WhoIam();
}
</code></pre><p>下面是Worker类</p>
<pre><code>public class Worker implements Employee{

    private String name;
    public Worker(String name){
        this.name = name;
    }
    @Override
    public void WhoIam() {
        System.out.println(&quot;My name is &quot;+getName()+&quot; i am a worker&quot;);
    }
    public String getName() {
        return name;
    }
}
</code></pre><p>下面是Leader类</p>
<pre><code>public class Leader implements Employee{

    String name;
    List&lt;Employee&gt; workers = new ArrayList&lt;Employee&gt;();
    public Leader(String name){
        this.name = name;
    }
    public void add(Employee employee){
        workers.add(employee);
    }
    public void remove(Employee employee){
        workers.remove(employee);
    }
    public Employee getChild(int i){
        return workers.get(i);
    }
    @Override
    public void WhoIam() {
        System.out.println(&quot;My name is &quot;+getName()+&quot; i am a leader,i have &quot;+workers.size()+&quot; employee&quot;);
        for(Employee employee:workers){
            employee.WhoIam();
        }
    }
    public String getName() {
        return name;
    }

}
</code></pre><p>测试类</p>
<pre><code>public class Client {
    public static void main(String[] args) {
        Leader leader1 = new Leader(&quot;张三&quot;);
        Leader leader2 = new Leader(&quot;李四 &quot;);
        Worker worker1 = new Worker(&quot;小明&quot;);
        Worker worker2 = new Worker(&quot;小李&quot;);
        Worker worker3 = new Worker(&quot;小王&quot;);
        Worker worker4 = new Worker(&quot;小张&quot;);
        leader1.add(leader2);

        leader1.add(worker1);
        leader1.add(worker2);
        leader2.add(worker3);
        leader2.add(worker4);
        leader1.WhoIam();

    }
}
</code></pre><p>结果：</p>
<pre><code>My name is 张三 i am a leader,i have 3 employee
My name is 李四  i am a leader,i have 2 employee
My name is 小王 i am a worker
My name is 小张 i am a worker
My name is 小明 i am a worker
My name is 小李 i am a worker
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/11/HeadFirst设计模式笔记-迭代器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/11/HeadFirst设计模式笔记-迭代器模式/" itemprop="url">HeadFirst设计模式笔记-迭代器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-11T19:03:40+08:00">
                2015-12-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h3><p>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>
<h3 id="为什么要用迭代器"><a href="#为什么要用迭代器" class="headerlink" title="为什么要用迭代器"></a>为什么要用迭代器</h3><p>存储方式有很多种，有集合和数组，如果不同的类使用不同的存储方式，这样遍历起来就很麻烦。可能要写几个for 循环做遍历这件事。如果有迭代器的话，就不会有这样的问题，它内部封装了遍历的方法。让任何实现它接口的集合都可以用它内部实现方法去遍历。</p>
<p>Java内部有自己的迭代器 Iterator，也可以自己实现迭代器。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>这个例子是关于菜单，两份不同的菜单，它们有不同的存储方式，一个是数组存储，一个是集合存储。</p>
<p>首先是迭代器接口</p>
<pre><code>public interface Iterator {
boolean hasNext();
Object next();
}
</code></pre><p>然后是两个迭代器接口的具体实现，它们分别是两家不同的餐厅</p>
<pre><code>public class DinerMenuIterator implements Iterator{

MenuItem[] items;
int position = 0;
public DinerMenuIterator(MenuItem[] items){
    this.items = items;
}
@Override
public boolean hasNext() {
    if(position &gt;= items.length || items[position] == null){
        return false;
    }else{
        return true;
    }
}

@Override
public Object next() {
    MenuItem menuItem = items[position];
    position = position + 1;
    return menuItem;
}
}
</code></pre><p>另一家餐厅迭代器</p>
<pre><code>public class PancakeIterator implements Iterator{

List&lt;MenuItem&gt; menuItems;
int position = 0;

public PancakeIterator(List&lt;MenuItem&gt; menuItems) {
    this.menuItems = menuItems;
}
@Override
public boolean hasNext() {
    if(position &gt; menuItems.size()-1 || menuItems.get(position)==null){
        return false;
    }else{
        return true;
    }
}

@Override
public Object next() {
    MenuItem menuItem = menuItems.get(position);
    position++;
    return menuItem;
}
}
</code></pre><p>菜单接口</p>
<pre><code>public interface Menu {
public Iterator createIterator();
}
</code></pre><p>下面是俩家餐厅都同意的一个菜单模板，后面两家都以此创建对象。</p>
<pre><code>public class MenuItem {
String name;
String description;
boolean vegetarian;
double price;

public MenuItem(String name,String description,boolean vegetarian,double price){
    this.name = name;
    this.description = description;
    this.vegetarian = vegetarian;
    this.price = price;
}
public String getName() {
    return name;
}
public String getDescription() {
    return description;
}
public double getPrice() {
    return price;
}
public boolean isVegetarian() {
    return vegetarian;
}
}
</code></pre><p>第一家菜单</p>
<pre><code>public class DinerMenu implements Menu{
static final int MAX_ITEMS = 6;
int numberOfItems = 0;
MenuItem[] menuItems;

public DinerMenu() {
    menuItems = new MenuItem[MAX_ITEMS];
    addItem(&quot;Vigetarian BLT&quot;, &quot;Bacon with lettuce &amp; tomato on whole wheat&quot;,
            true, 2.99);
    addItem(&quot;Soup of the day&quot;,
            &quot;Soup of the day with a side of potato salad&quot;, false, 3.29);
    addItem(&quot;BLT&quot;, &quot;Bacon with lettuce &amp; tomato on whole wheat&quot;, false,
            2.99);
    addItem(&quot;Hotdog&quot;,
            &quot;a hot dog,with saurkraut,relish,onions,topped with cheese&quot;,
            false, 3.05);
}

public void addItem(String name, String description, boolean vegetarian,
        double price) {
    MenuItem menuItem = new MenuItem(name, description, vegetarian, price);
    if (numberOfItems &gt;= MAX_ITEMS) {
        System.err.println(&quot;Sorry,menu is full!Can&apos;t add item to menu&quot;);
    } else {
        menuItems[numberOfItems] = menuItem;
        numberOfItems = numberOfItems + 1;
    }

}
@Override
public Iterator createIterator() {
    return new DinerMenuIterator(menuItems);
}
}
</code></pre><p>别看那么多代码，很多都是废话。它就是创建对象，存储到数组中。createIterator()这个方法不懂可以暂时忽略。</p>
<p>第二家菜单</p>
<pre><code>public class PancakeHouseMenu implements Menu{
ArrayList&lt;MenuItem&gt; menuItems;

public PancakeHouseMenu() {
    menuItems = new ArrayList&lt;MenuItem&gt;();

    addItem(&quot;K&amp;B&apos;s Pancake Breakfast&quot;,
            &quot;Pancakes with scrambled eggs, and toast&quot;, true, 2.99);
    addItem(&quot;Regular Pancake Breakfast&quot;,
            &quot;Pancakes with fried eggs, sausasge&quot;, false, 2.99);
    addItem(&quot;Blueberry Pancakes&quot;, &quot;Pancakes made with fresh blueberries&quot;,
            true, 3.49);
    addItem(&quot;Waffles&quot;,
            &quot;Waffles,with your vhoice of blueberries or strawberries&quot;,
            true, 3.59);
}

public void addItem(String name, String description, boolean vegerarian,
        double price) {
     MenuItem menuItem = new MenuItem(name,description,vegerarian,price);
     menuItems.add(menuItem);
}
@Override
public Iterator createIterator() {
    return new PancakeIterator(menuItems);
}
}
</code></pre><p>这家跟上家差不多，只不过它的存储方式为集合。</p>
<p>下面这个类是服务员，它负责点餐，迭代器模式方便了她，只用一种方式就遍历了。</p>
<pre><code>public class Waitress {
Menu pancakeHouseMenu;
Menu dinerMenu;

public Waitress(Menu pancakeHouseMenu,Menu dinerMenu) {
    this.pancakeHouseMenu = pancakeHouseMenu;
    this.dinerMenu = dinerMenu;
}
public void printMenu(){
    Iterator dinerMenuIterator = dinerMenu.createIterator();
    System.out.println(&quot;MENU\n----\nbreakfase:&quot;);
    printMenu(dinerMenuIterator);


    System.out.println(&quot;------------------&quot;);
    Iterator pancakeIterator = pancakeHouseMenu.createIterator();
    System.out.println(&quot;lunch:&quot;);
    printMenu(pancakeIterator);
}
private void printMenu(Iterator iterator){
    while(iterator.hasNext()){
        MenuItem menuItem = (MenuItem) iterator.next();
        System.out.print(menuItem.getName()+&quot;,&quot;);
        System.out.print(menuItem.getPrice()+&quot; &quot;);
        System.out.println(menuItem.getDescription()+&quot;--&quot;);
    }
}
}
</code></pre><p>createIterator() 方法在这里起作用了，被调用创建对应的迭代器对象，然后通过这个对象遍历。</p>
<p>测试类</p>
<pre><code>public class MenuTest {
public static void main(String[] args) {
    DinerMenu dinerMenu = new DinerMenu();
    PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu();
    Waitress waitress = new Waitress(pancakeHouseMenu,dinerMenu);
    waitress.printMenu();
}
}
</code></pre><p>结果：</p>
<pre><code>MENU
----
breakfase:
Vigetarian BLT,2.99 Bacon with lettuce &amp; tomato on whole wheat--
Soup of the day,3.29 Soup of the day with a side of potato salad--
BLT,2.99 Bacon with lettuce &amp; tomato on whole wheat--
Hotdog,3.05 a hot dog,with saurkraut,relish,onions,topped with cheese--
------------------
lunch:
K&amp;B&apos;s Pancake Breakfast,2.99 Pancakes with scrambled eggs, and toast--
Regular Pancake Breakfast,2.99 Pancakes with fried eggs, sausasge--
Blueberry Pancakes,3.49 Pancakes made with fresh blueberries--
Waffles,3.59 Waffles,with your vhoice of blueberries or strawberries--
</code></pre><p>上面的代码由于废话太多显得有点乱，我们来整理一下。</p>
<p><img src="http://i12.tietuku.com/5f9f52d430ea756d.png" alt="1"></p>
<p>DinerMenu 和 PancakeHouseMenu 里面都有 createIterator 方法返回对应的菜单迭代器对象。在Waitress 里面调用这个方法得到相应的迭代器进行遍历。为什么迭代器可以遍历菜单的内容？因为迭代器对象的构造方法里面传入了一个菜单对象，所以可以遍历。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>迭代器模式适用于不同的存储方法遍历，迭代器可以封装方法，从而对任何实现迭代器接口的进行遍历。</p>
</li>
<li><p>迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部的表示。</p>
</li>
<li><p>把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。</p>
</li>
<li><p>迭代器模式符合单一责任，单一责任原则即一个类应该只有一个引起变化的原因。迭代器就是把多个变为一个。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/10/HeadFirst设计模式笔记-模板方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/10/HeadFirst设计模式笔记-模板方法模式/" itemprop="url">HeadFirst设计模式笔记-模板方法模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-10T13:37:06+08:00">
                2015-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h3><p>定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法是的子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>简单的说，就是把一些共有的方法放在一个抽象类中，这个类中定义了一些共有的方法，这些方法子类不必去实现，还有一些定义为抽象方法，这些方法是各子类有所差异的地方，所以要子类自己去覆写。有一些方法，被称为钩子，它不被定义成抽象方法，子类可以选择是否覆写它。它的作用是可以改变父类的一些行为。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>煮茶和煮咖啡的步骤基本是重复的，只是有些具体实现不同。这时就可以用到模式方法模式。</p>
<p>下面我们先写出总的抽象类</p>
<pre><code>public abstract class CaffeineBeverage {
void prepareRecipe(){
    boilWater(); //煮水
    brew();      //酿造
    pourInCup(); //倒进杯子中
    if(customerWantsCondiments()){
        addCondiments();//添加调料
    }
}
abstract void brew();
abstract void addCondiments();

void boilWater(){
    System.out.println(&quot;Boiling water&quot;);
}
void pourInCup(){
    System.out.println(&quot;Pouring into cup&quot;);
}
boolean customerWantsCondiments(){//“钩子”
    return true;
}
}    
</code></pre><p>可以看到，上面的一些方法可以在煮咖啡和茶之间通用，所以直接写好了。还有一些定义为抽象，让子类自己去实现。这个抽象类中还定义了“钩子”方法，它可以在子类中重写，然后影响这个类，是否加调料。</p>
<p>下面是咖啡类</p>
<pre><code>public class Coffee extends CaffeineBeverage{

@Override
void addCondiments() {
    System.out.println(&quot;Adding Sugar ang Milk&quot;);
}
@Override
void brew() {
    System.out.println(&quot;Driping Coffee through filter&quot;);
}
@Override
boolean customerWantsCondiments() {
    String answer = getUserInput();
    if(answer.toLowerCase().startsWith(&quot;y&quot;)){
        return true;
    }
    return false;
}
public String getUserInput(){
    String answer = null;
    System.out.println(&quot;Would you like add Condiments?(y/n)&quot;);
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    try {
        answer = in.readLine();

    } catch (IOException e) {
        e.printStackTrace();
    }
    if(answer==null){
        return &quot;no&quot;;
    }
    return answer;

}
}
</code></pre><p>下面是茶类</p>
<pre><code>public class Tea extends CaffeineBeverage{

@Override
void addCondiments() {
    System.out.println(&quot;add some condiments&quot;);
}

@Override
void brew() {
    System.out.println(&quot;Driping Tea through filter&quot;);
}
@Override
boolean customerWantsCondiments() {
    String answer = getUserInput();
    if(answer.toLowerCase().startsWith(&quot;y&quot;)){
        return true;
    }
    return false;
}

private String getUserInput() {
    String answer = null;
    System.out.println(&quot;Would you like some condiments?(y/n)&quot;);
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    try {
        answer = in.readLine();
    } catch (IOException e) {
        e.printStackTrace();
    }
    if(answer==null){
        return &quot;no&quot;;
    }
    return answer;
}
}
</code></pre><p>测试类</p>
<pre><code>public class Test {
public static void main(String[] args) {
    Coffee coffee = new Coffee();
    System.out.println(&quot;making coffee...&quot;);
    coffee.prepareRecipe();

    Tea tea = new Tea();
    System.out.println(&quot;making tea...&quot;);
    tea.prepareRecipe();
}
}
</code></pre><p>结果：</p>
<pre><code>making coffee...
Boiling water
Driping Coffee through filter
Pouring into cup
Would you like add Condiments?(y/n)
n
making tea...
Boiling water
Driping Tea through filter
Pouring into cup
Would you like some condiments?(y/n)
y
add some condiments
</code></pre><p>上面的子类都复写了“钩子方法”，让用户输入，以影响父类的方法。</p>
<h3 id="现实中的模板方法模式"><a href="#现实中的模板方法模式" class="headerlink" title="现实中的模板方法模式"></a>现实中的模板方法模式</h3><p>Arrays.sort() 这个系统提供的方法就利用了模板方法模式，现实中的模式往往不容易看出来。sort方法是静态的，这样所有数组都可以利用它排序，它需要实现Comparable接口并重写其中的 compareTo（）方法，否则无法排序。</p>
<pre><code>public class Duck implements Comparable {

String name;
int weight;

public Duck(String name, int weight) {
    this.name = name;
    this.weight = weight;
}

public String toString() {
    return name + &quot; weights &quot; + weight;
}

@Override
public int compareTo(Object o) {
    Duck otherDuck = (Duck) o;
    if (this.weight &lt; otherDuck.weight) {
        return -1;
    } else if (this.weight == otherDuck.weight) {
        return 0;
    }else{
        return 1;
    }

}
}
</code></pre><p>这个compareTo方法就相当于上面的“钩子”，它需要子类去实现，按照子类的需求进行排序。</p>
<pre><code>public class DuckSortTest {
public static void main(String[] args) {
    Duck[] ducks = {
            new Duck(&quot;Daffy&quot;,8),
            new Duck(&quot;Tom&quot;,15),
            new Duck(&quot;Huey&quot;,6),
            new Duck(&quot;Howard&quot;,2)
    };
    System.out.println(&quot;before sorting:&quot;);
    display(ducks);

    Arrays.sort(ducks);

    System.out.println(&quot;after sorting:&quot;);
    display(ducks);
}
public static void display(Duck[] ducks){
    for (int i = 0; i &lt; ducks.length; i++) {
        System.out.println(ducks[i]);
    }
}
}
</code></pre><p>结果：</p>
<pre><code>before sorting:
Daffy weights 8
Tom weights 15
Huey weights 6
Howard weights 2

after sorting:
Howard weights 2
Huey weights 6
Daffy weights 8
Tom weights 15
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>模板方法模式就是一个父类里面定义一些子类中可以通用的方法，子类不能通用的部分交给子类去覆写，然后反过来影响父类中的方法。</li>
</ul>
<ul>
<li><p>模板方法的抽象类可以定义具体方法，抽象方法和钩子。抽象方法由子类实现。钩子是一种方法，它在抽象类中不做事，或者只做默认的事，子类可以选择要不要去覆盖它。</p>
</li>
<li><p>为了防止子类改变模板方法，可以将模板方法声明为final.</p>
</li>
<li><p>策略模式和模板方法模式都封装算法，一个用组合，一个用继承。</p>
</li>
<li><p>工厂方法是模板方法的一种特殊版本。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/09/HeadFirst设计模式笔记-适配器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/09/HeadFirst设计模式笔记-适配器模式/" itemprop="url">HeadFirst设计模式笔记-适配器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-09T17:30:20+08:00">
                2015-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是适配器"><a href="#什么是适配器" class="headerlink" title="什么是适配器"></a>什么是适配器</h3><p>定义：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<p>举个现实中的例子，你去一个国家旅游，这个国家的充电插头和你充电器上的插头是不匹配的，通常需要一个转换插头。这个转换插头就是适配器。它的作用是把两个不能连接起来工作的东西连接起来。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>中国旅客住在德国一家宾馆，德国的插头是两项插头，中国的是三项插头。这个时候就需要适配器。</p>
<pre><code>public interface GermanSocketInterface {
public void charging();
}

public class GermanSocket implements GermanSocketInterface{

@Override
public void charging() {
    System.out.println(&quot;使用德国两项插头充电&quot;);
}

}
</code></pre><p>下面是中国的充电插头</p>
<pre><code>public interface ChinaSocketInterface {
public void charging();
}

public class ChinaSocket implements ChinaSocketInterface{

@Override
public void charging() {
    System.out.println(&quot;使用中国三项插头充电&quot;);
}
}
</code></pre><p>下面是德国的宾馆</p>
<pre><code>public class Hotel {
private GermanSocketInterface Gsocket;
public Hotel(){}
public Hotel(GermanSocketInterface Gsocket){
    this.Gsocket = Gsocket;
}
public void setSocket(GermanSocketInterface Gsocket){
    this.Gsocket = Gsocket;
}
public void charge(){
    Gsocket.charging();
}
}
</code></pre><p>在德国的宾馆里是德国式的插孔，它只接受德式接口，也就是我们程序里面实现德式接口的类。</p>
<p>下面是适配器。</p>
<pre><code>public class ChargeAdapter implements GermanSocketInterface{

private ChinaSocket Csocket; 
public ChargeAdapter(ChinaSocket Csocket) {
    this.Csocket = Csocket;
}
@Override
public void charging() {
    System.out.println(&quot;插上转换器&quot;);
    Csocket.charging();
}

}
</code></pre><p>这个适配器实现了德式接口，可以传入上面的setSocket方法，然后它还有中式插头的引用，可以实现插上中式插头。也就是，它前面是两项插头，然后屁股保有三项插头的孔。这就是转换器。</p>
<p><img src="http://i5.tietuku.com/8fb421a6166bf6ca.jpg" alt="转换插头"></p>
<p>测试类</p>
<pre><code>public class Test {
public static void main(String[] args) {

    Hotel hotel = new Hotel();
    ChinaSocket Csocket = new ChinaSocket();
    ChargeAdapter adpter = new ChargeAdapter(Csocket);
    hotel.setSocket(adpter);

    hotel.charge();
}
}
</code></pre><p>结果：</p>
<pre><code>插上转换器
使用中国三项插头充电
</code></pre><p>在测试类里面看起来，适配器模式和装饰者模式有点像，其实他们的意图是完全不同的。装饰者是为了给被装饰者添加新的行为。而适配器是为了转换接口，让两个类能连接起来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/08/HeadFirst设计模式笔记-命令模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/08/HeadFirst设计模式笔记-命令模式/" itemprop="url">HeadFirst设计模式笔记-命令模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-08T16:43:06+08:00">
                2015-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="了解命令模式"><a href="#了解命令模式" class="headerlink" title="了解命令模式"></a>了解命令模式</h3><p>定义：</p>
<p>命令模式将请求封装成对象，以便使用不同的的请求，队列或日志来参数化其他对象。命令模式也支持可撤销操作。</p>
<p>命令对象通过在特定接收者上绑定一组动作来封装请求。命令对象将动作个接受者包进对象中，这个对象只对外暴露一个execute（）方法，接受者就会进行动作。从外面看，其他对象不知道究竟哪个接收者进行了哪些动作，只知道如果调用execute()方法，请求的目的就达到了。</p>
<p><img src="http://i5.tietuku.com/cf909c4600d60ad1.png" alt="a"></p>
<ul>
<li><p>Client： 这个客户负责创建 ConcreteCommand，并设置其接收者。</p>
</li>
<li><p>Inoker： 这个调用者持有一个命令对象，并在某个时间点调用命令对象的execute()方法，使请求付诸实践。</p>
<p>  这个相当于下面例子的SimpleRemoteControl。</p>
</li>
<li><p>Command： 所有命令的接口，实现此接口就可传入Inoker。</p>
</li>
<li><p>ConcreteCommand：这个是命令的具体实现，里面有接受者的引用，目的是调用接受者的方法。</p>
<p>  相当于下面例子的LightOnCommand，接收者是Light。</p>
</li>
<li><p>Recerver： 接收者</p>
</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>这个例子是一个遥控，它可以控制灯的开关，在这里只写了开的动作。</p>
<pre><code>public class Light {

public void on(){
    System.out.println(&quot;light is on&quot;);
}
public void off(){
    System.out.println(&quot;light is off&quot;);
}
}
</code></pre><p>所有命令都应该实现同一个接口。</p>
<pre><code>public interface Command {
public void execute();
}
</code></pre><p>下面这个类实现了Command接口，是开灯的命令。</p>
<pre><code>public class LightOnCommand implements Command{

Light light;
public LightOnCommand(Light light) {
    this.light = light;
}
@Override
public void execute() {
    light.on();
}
}
</code></pre><p>这个类里面有设置命令的方法，只要实现了Command接口的命令都可以传入，这样实现了解耦，它不需要知道具体的命令是什么，而且可以随时修改命令。</p>
<pre><code>public class SimpleRemoteControl {
Command slot;
public SimpleRemoteControl(){}
public void setCommand(Command command){
    slot = command;
}
public void buttonWasPressed(){
    slot.execute();
}
}
</code></pre><p>最后是测试类</p>
<pre><code>public class RemoteControlTest {
public static void main(String[] args) {
    SimpleRemoteControl remote = new SimpleRemoteControl();
    Light light = new Light();
    LightOnCommand lightOn = new LightOnCommand(light);

    remote.setCommand(lightOn);
    remote.buttonWasPressed();
}
}
</code></pre><p>结果：      </p>
<pre><code>light is on
</code></pre><h3 id="其他用途"><a href="#其他用途" class="headerlink" title="其他用途"></a>其他用途</h3><p>1.队列请求</p>
<p>将命令打包，形成队列，另一边从队列中取出一个命令，调用execute()方法。工作队列类和进行计算的对象之间是完全解耦的。此刻线程可能在执行财务运算，下一刻却在读取网络数据，工作队列不在乎做什么，它只是取出命令，执行。只要实现命令模式对象，就可以放入队列执行。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>命令模式将请求封装成对象，这可以让你使用不同的请求，队列来参数化对象。命令模式也可以支持撤销操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/07/HeadFirst设计模式笔记-工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tangyingqi">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangyingqi's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/07/HeadFirst设计模式笔记-工厂模式/" itemprop="url">HeadFirst设计模式笔记-工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-07T17:36:10+08:00">
                2015-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式不是设计模式，它是工厂模式的基础。了解简单工厂模式，对理解工厂模式有帮助。</p>
<h3 id="什么是简单工厂模式"><a href="#什么是简单工厂模式" class="headerlink" title="什么是简单工厂模式"></a>什么是简单工厂模式</h3><p>工厂模式就是把创建对象的工作封装成一个单独的类，你可以通过工厂得到你需要的对象。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>一家批萨店，有不同口味的批萨，通过一个简单工厂类封装创建对象的工作。</p>
<p>首先需要抽象出一个pizza超类</p>
<pre><code>public abstract class Pizza {
    abstract void display();
}
</code></pre><p>创建两种Pizza类继承超类</p>
<pre><code>public class CheesePizza extends Pizza{

@Override
void display() {
    System.out.println(&quot;make a CheesePizza&quot;);
}
}

public class PepperoniPizza extends Pizza{

@Override
void display() {
    System.out.println(&quot;make a PepperoniPizza&quot;);
}
}
</code></pre><p>创建一个简单工厂类</p>
<pre><code>public class SimplePizzaFactory {

public Pizza createPizza(String type){
    Pizza pizza = null;
    if(type.equals(&quot;cheese&quot;)){
        pizza = new CheesePizza();
    }else if(type.equals(&quot;pepperoni&quot;)){
        pizza = new PepperoniPizza();
    }
    return pizza;
}
}
</code></pre><p>现在可以生产pizza啦</p>
<pre><code>public class MakePizza {
public static void main(String[] args) {
    SimplePizzaFactory factory = new SimplePizzaFactory();
    Pizza pizza = factory.createPizza(&quot;pepperoni&quot;);
    pizza.display();
    Pizza pizza1 = factory.createPizza(&quot;cheese&quot;);
    pizza1.display();
}
}
</code></pre><p>结果：<br>make a PepperoniPizza<br>make a CheesePizza</p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h3 id="什么是工厂模式，它跟简单工厂有什么区别"><a href="#什么是工厂模式，它跟简单工厂有什么区别" class="headerlink" title="什么是工厂模式，它跟简单工厂有什么区别"></a>什么是工厂模式，它跟简单工厂有什么区别</h3><p>同样，工厂模式的整体思想就是封装创建对象的工作，但是不同于简单工厂模式，它的工厂是抽象的，也就是说可以有其他工厂加入进来。而且工厂中会带有抽象的工厂方法，它的实现由子类去实现，返回给它对象。这样程序就更加灵活了，因为，你不知道该创建什么对象，而子类最清楚(或者说消费者最清楚)，那就交给子类去做。</p>
<p>上面的例子，虽然做到了加不同的东西，做出不同的批萨。但是现实情况是，加同样的东西，不同的地方的口味也不一样。这该怎么做呢？显然上面的例子不容易扩展了。</p>
<p>看下面这个例子，它加入了纽约风味，为了减少代码量就加这一个了。</p>
<p>首先我们看工厂类发生了什么变化</p>
<pre><code>public abstract class PizzaStore {//变成了抽象方法

public Pizza orderPizza(String type){
    Pizza pizza;
    pizza = createPizza(type);

    return pizza;
}
abstract Pizza createPizza(String type);//这个抽象方法是工厂方法，让子类去实现
}
</code></pre><p>然后出现类纽约的工厂类继承上面的工厂类，来制作纽约风味的批萨。</p>
<pre><code>public class NYStylePizzaStore extends PizzaStore{

@Override
Pizza createPizza(String type) {
    if(type.equals(&quot;cheese&quot;)){
        return new NYStyleCheesePizza();
    }else if(type.equals(&quot;pepperoni&quot;)){
        return new NYStylePepperoniPizza();
    }
    return null;
}
}
</code></pre><p>纽约工厂提供了两种批萨，分别是</p>
<pre><code>public class NYStyleCheesePizza extends Pizza{

@Override
void display() {
    System.out.println(&quot;NYStyle and Cheese Pizza&quot;);
}
}

public class NYStylePepperoniPizza extends Pizza{

@Override
void display() {
    System.out.println(&quot;NyStyle and Pepperoni Pizza&quot;);
}
}
</code></pre><p>下面就可以开始制作了</p>
<pre><code>public class MakePizzaTest {
public static void main(String[] args) {
    PizzaStore nyPizzaStore = new NYStylePizzaStore();
    Pizza pizza = nyPizzaStore.orderPizza(&quot;cheese&quot;);
    pizza.display();
}
}
</code></pre><p>结果是：</p>
<pre><code>NYStyle and Cheese Pizza
</code></pre><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h3 id="抽象工厂和工厂模式的区别"><a href="#抽象工厂和工厂模式的区别" class="headerlink" title="抽象工厂和工厂模式的区别"></a>抽象工厂和工厂模式的区别</h3><p>抽象工厂模式的定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p>
<p>它们的工作都是创建对象，工厂模式是用继承，而抽象工厂是通过对象的组合。</p>
<p>抽象工厂提供一个用来创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。</p>
<p>产品家族：比如苹果公司就是一个产品家族，它不光有手机，还有电脑，平板一系列的产品。</p>
<h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code> public interface Apple{

    void AppleStyle();
 }

public interface Sumsung{

     void SumsungStyle();
 }

public class iPhone implements Apple{

@Override
public void AppleStyle() {
    System.out.println(&quot;this is AppleStyle phone&quot;);
}
}

public class iPad implements Apple{

@Override
public void AppleStyle() {
    System.out.println(&quot;This is Apple pad&quot;);
}
}

public class Note implements Sumsung{

@Override
public void SumsungStyle() {
    System.out.println(&quot;This is Sumsung phone&quot;);
}
}

public class SumsungPad implements Sumsung{

@Override
public void SumsungStyle() {
    System.out.println(&quot;This is Sumsung pad&quot;);
}
}

public interface Factory {//工厂方法定义为接口
    Apple createAppleProduct();
    Sumsung createSumsungProduct();
}
//手机工厂
public class Factory_phone implements Factory{

@Override
public Apple createAppleProduct() {
    return new iPhone();
}

@Override
public Sumsung createSumsungProduct() {
    return new Note();
}
}
//平板工厂
public class Factory_Pad implements Factory{

@Override
public Apple createAppleProduct() {
    return new iPad();
}

@Override
public Sumsung createSumsungProduct() {
    return new SumsungPad();
}
}
</code></pre><p>测试类</p>
<pre><code>public class Test {
public static void main(String[] args) {
    Factory factory = new Factory_phone();
    Apple phone = factory.createAppleProduct();
    phone.AppleStyle();

    Factory factory1 = new Factory_Pad();
    Sumsung pad = factory1.createSumsungProduct();
    pad.SumsungStyle();
}
}    
</code></pre><p>结果：    </p>
<pre><code>this is AppleStyle phone
This is Sumsung pad
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂模式有两种，普通工厂模式和抽象工厂模式。它们的工作都是一样的，只是抽象工厂模式服务于更大型的需求。利用接口实现，对象组合。缺点是想要添加新的种类，就要改接口中的内容。需要改的代码很多。</p>
<p>一句话总结工厂模式就是，使用抽象类中的抽象方法，让子类自己去实现创建对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Tangyingqi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tangyingqi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
